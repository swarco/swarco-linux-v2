diff -Nrub '--exclude=*~' linux-orig/arch/arm/boot/compressed/head-at91rm9200.S linux-2.6.21-ccm2200/arch/arm/boot/compressed/head-at91rm9200.S
--- linux-orig/arch/arm/boot/compressed/head-at91rm9200.S	2016-03-22 14:41:04.000000000 +0100
+++ linux-2.6.21-ccm2200/arch/arm/boot/compressed/head-at91rm9200.S	2015-06-18 10:41:42.000000000 +0200
@@ -73,6 +73,19 @@
 		cmp	r7, r3
 		beq	99f
 
+		@ Promwad Chub : 1181
+		mov	r3,	#(MACH_TYPE_CHUB & 0xff)
+		orr	r3, r3, #(MACH_TYPE_CHUB & 0xff00)
+		cmp	r7, r3
+		beq	99f
+
+                /* 2006-04-26 gc: support CCM 2200 */
+       		@ SWARCO Traffic Systems GmbH CCM2200 board : 1014
+		mov	r3,	#(MACH_TYPE_CCM2200 & 0xff)
+		orr	r3, r3, #(MACH_TYPE_CCM2200 & 0xff00)
+		cmp	r7, r3
+		beq	99f
+
 		@ Unknown board, use the AT91RM9200DK board
 		@ mov	r7, #MACH_TYPE_AT91RM9200
 		mov	r7,	#(MACH_TYPE_AT91RM9200DK & 0xff)
diff -Nrub '--exclude=*~' linux-orig/arch/arm/mach-at91/ccm2200/at91-uart-ccm2200.c linux-2.6.21-ccm2200/arch/arm/mach-at91/ccm2200/at91-uart-ccm2200.c
--- linux-orig/arch/arm/mach-at91/ccm2200/at91-uart-ccm2200.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-ccm2200/arch/arm/mach-at91/ccm2200/at91-uart-ccm2200.c	2015-06-18 10:41:42.000000000 +0200
@@ -0,0 +1,523 @@
+/*
+ * linux/arch/arm/mach-at91rm9200/at91-uart-ccm2200.c
+ *
+ * Copyright (C) 2006 by Weiss-Electronic 
+ * Copyright (C) 2010 by SWARCO Traffic Systems GmbH.
+ * All rights reserved.
+ *
+ * @author:     Guido Classen <guido.classen@swarco.de>
+ * @descr:      Subclass driver for AT91RM9200 UARTs on CCM2200
+ *              This module drives the additional modem control lines
+ *              over AT91 GPIO ports
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  @par Modification History:
+ *     2006-05-04 gc: initial version
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+
+
+#include <asm/hardware.h>
+#include <asm/setup.h>
+#include <asm/irq.h>
+
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/board.h>
+#include <asm/arch/board-ccm2200.h>
+#include <asm/arch/at91-util.h>
+#include <asm/arch/at91_pio.h>
+#include <asm/mach/serial_at91.h>
+
+#include <linux/serial_core.h>
+//#include <asm/mach/serial_at91rm9200.h>
+//#include <asm/arch/AT91RM9200_USART.h>
+
+#include <asm/hardware.h>
+
+#include "../../../../drivers/serial/atmel_serial.h"
+//#include <asm/arch/pio.h>
+
+/* only use this module if AT91 serial support is compiled in */
+#ifdef CONFIG_SERIAL_ATMEL
+
+
+#define AT91_USART0     0
+#define AT91_USART1     1
+#define AT91_USART2     2
+#define AT91_USART3     3
+#define AT91_USART_DBG  4
+
+/*
+ * Serial port configuration.
+ * The AT91RM9200 serial ports are used as follows on the CCM2200 board:
+ *
+ *   USART0: COM2
+ *   USART1: COM1
+ *   USART2: COM5 Console
+ *   USART3: COM6
+ *   USART_DBG: optional available on COM5 connector instead of hardware flow
+ *              control signals RTS/CTS. These pins will be automatically
+ *              switched to the Debug USART if the correponding device is
+ *              opended!
+ *
+ */
+
+/*
+ * Serial port configuration.
+ *    ttyS0 .. ttyS3 = USART0 .. USART3
+ *    ttyS4      = DBGU
+ */
+/* 2007-05-30 gc: no __initdata used by at91_get_usart */
+static struct at91_uart_config ccm2200_uart_config = {
+	.console_tty	= 2,				/* ttyS2 */
+	.nr_tty		= 5,
+        /* ttyS0, ..., ttyS4 */ 
+	.tty_map	= { AT91_USART0,          
+                            AT91_USART1,
+                            AT91_USART2,
+                            AT91_USART3,
+                            AT91_USART_DBG }
+};
+
+
+static inline int at91_get_usart(struct uart_port *port)
+{
+        return ccm2200_uart_config.tty_map[port->line];
+}
+
+#define UART_PUT_CR(port,v)	__raw_writel(v, (port)->membase + ATMEL_US_CR)
+#define UART_GET_MR(port)	__raw_readl((port)->membase + ATMEL_US_MR)
+#define UART_PUT_MR(port,v)	__raw_writel(v, (port)->membase + ATMEL_US_MR)
+#define UART_PUT_IER(port,v)	__raw_writel(v, (port)->membase + ATMEL_US_IER)
+#define UART_PUT_IDR(port,v)	__raw_writel(v, (port)->membase + ATMEL_US_IDR)
+#define UART_GET_IMR(port)	__raw_readl((port)->membase + ATMEL_US_IMR)
+#define UART_GET_CSR(port)	__raw_readl((port)->membase + ATMEL_US_CSR)
+#define UART_GET_CHAR(port)	__raw_readl((port)->membase + ATMEL_US_RHR)
+#define UART_PUT_CHAR(port,v)	__raw_writel(v, (port)->membase + ATMEL_US_THR)
+#define UART_GET_BRGR(port)	__raw_readl((port)->membase + ATMEL_US_BRGR)
+#define UART_PUT_BRGR(port,v)	__raw_writel(v, (port)->membase + ATMEL_US_BRGR)
+#define UART_PUT_RTOR(port,v)	__raw_writel(v, (port)->membase + ATMEL_US_RTOR)
+
+
+
+enum at91_dbg_uart_pin_cfg {
+        AT91_USART2_RTS_CTS,
+        AT91_USART_DBG_RX_TX
+};
+
+#define AT91C_PA17_TXD0		(1<<17)         //  USART 0 Transmit Data
+#define AT91C_PA18_RXD0		(1<<18)         //  USART 0 Receive Data
+#define AT91C_PA20_CTS0		(1<<20)         //  USART 0 Clear To Send
+#define AT91C_PD21_RTS0		(1<<21)         //  Usart 0 Ready To Send
+#define AT91C_PB20_TXD1		(1<<20)         //  USART 1 Transmit Data
+#define AT91C_PB21_RXD1		(1<<21)         //  USART 1 Receive Data
+#define AT91C_PB23_DCD1		(1<<23)         //  USART 1 Data Carrier Detect
+#define AT91C_PB24_CTS1		(1<<24)         //  USART 1 Clear To Send
+#define AT91C_PB25_DSR1		(1<<25)         //  USART 1 Data Set ready
+#define AT91C_PB26_RTS1		(1<<26)         //  USART 1 Ready To Send
+#define AT91C_PD25_DTR1		(1<<25)         //  USART 1 Data Terminal ready
+#define AT91C_PA22_RXD2		(1<<22)         //  USART 2 Receive Data
+#define AT91C_PA23_TXD2		(1<<23)         //  USART 2 Transmit Data
+#define AT91C_PA5_TXD3		(1<<5)          //  USART 3 Transmit Data
+#define AT91C_PA6_RXD3          (1<<6)          //  USART 3 Receive Data
+#define AT91C_PB0_RTS3          (1<<0)          //  USART 3 Ready To Send
+#define AT91C_PB1_CTS3		(1<<1)          //  USART 3 Clear To Send
+#define AT91C_PA30_CTS2         (1<<30)
+#define AT91C_PA31_RTS2         (1<<31)
+#define AT91C_PA30_DRXD         (1<<30)
+#define AT91C_PA31_DTXD         (1<<31)
+
+static void at91_config_dbg_uart_pins( enum at91_dbg_uart_pin_cfg cfg)
+{
+        switch (cfg) {
+        case AT91_USART2_RTS_CTS:
+/*                 AT91_SYS->PIOA_PDR = AT91C_PA30_CTS2 | AT91C_PA31_RTS2; */
+/*                 AT91_SYS->PIOA_BSR = AT91C_PA30_CTS2 | AT91C_PA31_RTS2; */
+                at91_sys_write(AT91_PIOA + PIO_PDR, 
+                               AT91C_PA30_CTS2 | AT91C_PA31_RTS2);
+                at91_sys_write(AT91_PIOA + PIO_BSR, 
+                               AT91C_PA30_CTS2 | AT91C_PA31_RTS2);
+                break;
+
+        case AT91_USART_DBG_RX_TX:
+/*                 AT91_SYS->PIOA_PDR = AT91C_PA30_DRXD | AT91C_PA31_DTXD; */
+/*                 AT91_SYS->PIOA_ASR = AT91C_PA30_DRXD | AT91C_PA31_DTXD; */
+                at91_sys_write(AT91_PIOA + PIO_PDR, 
+                               AT91C_PA30_DRXD | AT91C_PA31_DTXD);
+                at91_sys_write(AT91_PIOA + PIO_ASR, 
+                               AT91C_PA30_DRXD | AT91C_PA31_DTXD);
+                break;
+        }
+}
+
+static void ccm2200_at91_uart_enable_pins(int uart_num)
+{
+        switch (uart_num) {
+        case 0:
+                /* USART 0 */
+                /* on CCM2200 errata pin PA21 not used, instead: 
+                 * CTS0 on PA20
+                 * DTR  on PD20 (gpio)
+                 * RTS0 on PD21
+                 * DCD  on PD22 (gpio)
+                 * DSR  on PC14 (gpio)
+                 * RI   on PC15 (gpio)
+                 */
+                at91_sys_write(AT91_PIOA + PIO_PDR, 
+                               AT91C_PA17_TXD0 | AT91C_PA18_RXD0
+                               | AT91C_PA20_CTS0);
+
+                at91_sys_write(AT91_PIOD + PIO_PDR,
+                               AT91C_PD21_RTS0);
+                break;
+
+        case 1:
+                /* USART 1 */
+                /* on CCM2200: 
+                 * CTS1 on PB24
+                 * DTR1 on PD25
+                 * RTS1 on PB26
+                 * DCD1 on PB23 
+                 * DSR1 on PB25
+                 * RI   on PB27 (gpio)
+                 */                             
+                at91_sys_write(AT91_PIOB + PIO_PDR, 
+                               AT91C_PB20_TXD1 | AT91C_PB21_RXD1
+                               | AT91C_PB23_DCD1 | AT91C_PB24_CTS1
+                               | AT91C_PB25_DSR1 | AT91C_PB26_RTS1);
+                at91_sys_write(AT91_PIOD + PIO_PDR, AT91C_PD25_DTR1);
+                break;
+
+        
+        case 2:
+                /* USART 2 */
+                /* on CCM2200: 
+                 * CTS2 on PA30 (Periph B)
+                 * RTS2 on PA31 (Periph B)
+                 * (Console Port has no more modem control lines! )
+                 */                             
+                at91_sys_write(AT91_PIOA + PIO_PDR, 
+                               AT91C_PA22_RXD2 | AT91C_PA23_TXD2
+                               | AT91C_PA30_CTS2 | AT91C_PA31_RTS2);
+                at91_sys_write(AT91_PIOA + PIO_BSR, 
+                               AT91C_PA30_CTS2 | AT91C_PA31_RTS2);
+                break;
+
+        case 3:
+                /* USART 3 */
+                /* on CCM2200: 
+                 * CTS3 on PB1 (Periph B)
+                 * DTR  on PC3 (gpio)
+                 * RTS3 on PB0 (Periph B)
+                 * DCD  on PC0 (gpio)
+                 * DSR  on PC1 (gpio)
+                 * RI   on PC2 (gpio)
+                 */                             
+                at91_sys_write(AT91_PIOA + PIO_PDR, 
+                               AT91C_PA5_TXD3 | AT91C_PA6_RXD3);
+                at91_sys_write(AT91_PIOA + PIO_BSR, 
+                               AT91C_PA5_TXD3 | AT91C_PA6_RXD3);
+                at91_sys_write(AT91_PIOB + PIO_PDR, 
+                               AT91C_PB0_RTS3 | AT91C_PB1_CTS3);
+
+                at91_sys_write(AT91_PIOB + PIO_BSR, 
+                               AT91C_PB0_RTS3 | AT91C_PB1_CTS3);
+                break;
+        }
+}
+
+struct usart_mctrl_pins {
+        /* RxD/TxD and RTS/CTS are controlled by the USART */
+        struct at91_pio_pins dtr; /* output */
+        struct at91_pio_pins dcd; /* input */
+        struct at91_pio_pins dsr; /* input */
+        struct at91_pio_pins ri;  /* input */
+};
+
+static struct usart_mctrl_pins ccm2200_mctrl_cfg[ATMEL_MAX_UART] =
+{
+        /* USART0: COM2 */
+        {
+                .dtr = { AT91_PIO_BASE(AT91_PIOD), 1<<20 },
+                .dcd = { AT91_PIO_BASE(AT91_PIOD), 1<<22 },
+                .dsr = { AT91_PIO_BASE(AT91_PIOC), 1<<14 },
+                .ri  = { AT91_PIO_BASE(AT91_PIOC), 1<<15 }
+        },
+        /* USART1: COM1 (all modem control lines except RI can be controlled
+         *               by the USART) */
+
+        /* 2006-05-08 gc: control modem ctrl lines by software, since
+         *                USART seams not correctly work with DCD and DSR
+         *                in modem mode!
+         */
+#if 0
+        {
+                .dtr = { AT91_PIO_BASE(AT91_PIOA), 0 },
+                .dcd = { AT91_PIO_BASE(AT91_PIOA), 0 },
+                .dsr = { AT91_PIO_BASE(AT91_PIOA), 0 },
+                .ri  = { AT91_PIO_BASE(AT91_PIOB), 1<<27 }
+        },
+#else
+        /* for testing: modem control lines controled manually */
+        {
+                .dtr = { AT91_PIO_BASE(AT91_PIOD), 1<<25 },
+                .dcd = { AT91_PIO_BASE(AT91_PIOB), 1<<23 },
+                .dsr = { AT91_PIO_BASE(AT91_PIOB), 1<<25 },
+                .ri  = { AT91_PIO_BASE(AT91_PIOB), 1<<27 }
+        },
+#endif
+
+        /* USART2: COM5 Console: no additional modem control lines */
+        {
+                .dtr = { AT91_PIO_BASE(AT91_PIOA), 0 },
+                .dcd = { AT91_PIO_BASE(AT91_PIOA), 0 },
+                .dsr = { AT91_PIO_BASE(AT91_PIOA), 0 },
+                .ri  = { AT91_PIO_BASE(AT91_PIOA), 0 }
+        },
+
+        /* USART3: COM6 */
+        {
+                .dtr = { AT91_PIO_BASE(AT91_PIOC), 1<<3 },
+                .dcd = { AT91_PIO_BASE(AT91_PIOC), 1<<0 },
+                .dsr = { AT91_PIO_BASE(AT91_PIOC), 1<<1 },
+                .ri  = { AT91_PIO_BASE(AT91_PIOC), 1<<2 }
+        },
+        /* USART_DBG */
+        {
+                .dtr = { AT91_PIO_BASE(AT91_PIOA), 0 },
+                .dcd = { AT91_PIO_BASE(AT91_PIOA), 0 },
+                .dsr = { AT91_PIO_BASE(AT91_PIOA), 0 },
+                .ri  = { AT91_PIO_BASE(AT91_PIOA), 0 }
+        }
+};
+
+
+
+static inline
+int at91_have_modem_ctrl_pin(const struct at91_pio_pins *mctrl)
+{
+        register AT91S_PIO *pio = mctrl->pio;
+
+        if (pio) {
+                return 1;
+        }
+        return 0;
+}
+
+
+static void ccm2200_at91_set_mctrl(struct uart_port *port, u_int mctrl)
+{
+	unsigned int control = 0;
+        register struct usart_mctrl_pins *mctrl_pins =
+                &ccm2200_mctrl_cfg[at91_get_usart(port)];
+
+
+/*         printk("ccm2200_at91_set_mctrl[%d]  RTS: %d, DTR: %d\n", */
+/*                port->line, */
+/*                !!(mctrl & TIOCM_RTS), */
+/*                !!(mctrl & TIOCM_DTR)); */
+ 
+	if (mctrl & TIOCM_RTS)
+		control |= ATMEL_US_RTSEN;
+	else
+		control |= ATMEL_US_RTSDIS;
+
+	if (mctrl & TIOCM_DTR) {
+		control |= ATMEL_US_DTREN;
+                /* activated pin via GPIO if necessary, PIN is low active! */
+                at91_pio_clear_all_pins(&mctrl_pins->dtr);
+        } else {
+		control |=  ATMEL_US_DTRDIS;
+                /* deactivate pin via GPIO if necessary, PIN is low active! */
+                at91_pio_set_all_pins(&mctrl_pins->dtr);
+        }
+
+	UART_PUT_CR(port, control);
+}
+
+/*
+ * Get state of the modem control input lines
+ */
+static u_int ccm2200_at91_get_mctrl(struct uart_port *port)
+{
+	unsigned int status, ret = 0;
+        int usart_num = at91_get_usart(port);
+        register struct usart_mctrl_pins *mctrl_pins =
+                &ccm2200_mctrl_cfg[usart_num];
+
+        /* 
+         * if (usart_num == AT91_USART1 ) {
+         *         /\* enable modem mode for USART 1 *\/
+         *         UART_PUT_MR(port, (UART_GET_MR(port) & ~AT91C_US_USMODE) 
+         *                     | AT91C_US_USMODE_MODEM);
+         * }
+         */
+	status = UART_GET_CSR(port);
+
+        if (at91_have_modem_ctrl_pin(&mctrl_pins->dcd)) {
+                /* PIN is low active! */
+                if (!at91_pio_get_pins(&mctrl_pins->dcd))
+                        ret |= TIOCM_CD;
+        } else {
+                /* bug in at91_serial.c: all modem control signals are low
+                 *                       active!!!!
+                 */
+                if ((status & ATMEL_US_DCD) == 0)
+                        ret |= TIOCM_CD;
+        }
+        
+        /* bug in at91_serial.c: all modem control signals are low
+         *                       active on at91rm92000!!!!
+         */
+	if ((status & ATMEL_US_CTS) == 0)
+		ret |= TIOCM_CTS;
+
+        if (at91_have_modem_ctrl_pin(&mctrl_pins->dsr)) {
+                /* PIN is low active! */
+                if (!at91_pio_get_pins(&mctrl_pins->dsr))
+                        ret |= TIOCM_DSR;
+        } else {
+                /* bug in at91_serial.c: all modem control signals are low
+                 *                       active on at91rm92000!!!!
+                 */
+                if ((status & ATMEL_US_DSR) == 0)
+                        ret |= TIOCM_DSR;
+        }
+        if (at91_have_modem_ctrl_pin(&mctrl_pins->ri)) {
+                /* PIN is low active! */
+                if (!at91_pio_get_pins(&mctrl_pins->ri))
+                        ret |= TIOCM_RI;
+        } else {
+                /* bug in at91_serial.c: all modem control signals are low
+                 *                       active on at91rm92000!!!!
+                 */
+                if ((status & ATMEL_US_RI) == 0)
+                        ret |= TIOCM_RI;
+        }
+
+	return ret;
+}
+
+/*
+ * Enable modem status interrupts
+ */
+static void ccm2200_at91_enable_ms(struct uart_port *port)
+{
+        /* @todo: interrupt support for additional modem control lines */
+	// printk("ccm2200_at91_enable_ms(%d)\n", port->line);
+	UART_PUT_IER(port, ATMEL_US_RIIC | ATMEL_US_DSRIC 
+                     | ATMEL_US_DCDIC | ATMEL_US_CTSIC);
+
+        /* 2007-02-07 gc: bugfix, also set port->read_status_mask to enable
+         * additional sources in interrupt!!!!
+         */
+        port->read_status_mask |= ATMEL_US_RIIC | ATMEL_US_DSRIC 
+                | ATMEL_US_DCDIC | ATMEL_US_CTSIC;
+}
+
+static int ccm2200_at91_uart_open(struct uart_port *port)
+{
+        int usart_num = at91_get_usart(port);
+
+/*         printk("ccm2200_at91_uart_open: port: %d\n", port->line); */
+
+        ccm2200_at91_uart_enable_pins(usart_num);
+
+        /* route RXD/TXD from debug USART to CTS/RTS from USART0 as long
+         * the corresponding device is opened
+         */
+        if (usart_num ==  AT91_USART_DBG ) {
+                at91_config_dbg_uart_pins( AT91_USART_DBG_RX_TX );
+        }
+
+        {
+                register struct usart_mctrl_pins *mctrl_pins =
+                        &ccm2200_mctrl_cfg[usart_num];
+                at91_pio_set_all_pins(&mctrl_pins->dtr);
+                at91_pio_config_output_pins(&mctrl_pins->dtr);
+                at91_pio_config_input_pins(&mctrl_pins->dcd);
+                at91_pio_config_input_pins(&mctrl_pins->dsr);
+                at91_pio_config_input_pins(&mctrl_pins->ri);
+        }
+        return 0;
+};
+
+static void ccm2200_at91_uart_close(struct uart_port *port)
+{
+        //printk("ccm2200_at91_uart_close: port: %d\n", port->line);
+        /* restore routing of USART0 CTS/RTS */
+        if (at91_get_usart(port) ==  AT91_USART_DBG ) {
+                at91_config_dbg_uart_pins( AT91_USART2_RTS_CTS );
+        }
+}
+
+struct atmel_port_fns __initdata ccm2200_at91_port_fns = {
+        .set_mctrl = ccm2200_at91_set_mctrl,
+        .get_mctrl = ccm2200_at91_get_mctrl,
+        .enable_ms = ccm2200_at91_enable_ms,
+        .open      = ccm2200_at91_uart_open,
+        .close     = ccm2200_at91_uart_close
+
+};
+
+
+int __init ccm2200_at91_uart_init(void)
+{
+        /* Setup the serial ports and console */
+	at91_init_serial(&ccm2200_uart_config);
+
+	/* register UARTs */
+        atmel_register_uart_fns(&ccm2200_at91_port_fns);
+
+        /* confige modem control pins to USART2 the are reconfigured to
+         * the DEBUG USART if the coresponding device is opened
+         */
+        at91_config_dbg_uart_pins(AT91_USART2_RTS_CTS);
+        printk("CCM2200 AT91RM9200 internal UARTs successfully initialized\n");
+        return 0;
+}
+
+
+static void __exit ccm2200_at91_uart_exit(void)
+{
+}
+
+/*
+ * we musst call the init function in board-ccm2200.c to use the UART
+ * as serial console!
+ * module_init(ccm2200_at91_uart_init);
+ * module_exit(ccm2200_at91_uart_exit);
+ */
+
+MODULE_AUTHOR("Guido Classen");
+MODULE_DESCRIPTION("CCM2200 AT91RM9200 UART subclass driver");
+MODULE_LICENSE("GPL");
+
+#endif /* CONFIG_SERIAL_AT91 */
+
+/*
+ *Local Variables:
+ * mode: c
+ * c-file-style: "linux"
+ * End:
+ */
diff -Nrub '--exclude=*~' linux-orig/arch/arm/mach-at91/ccm2200/board-ccm2200.c linux-2.6.21-ccm2200/arch/arm/mach-at91/ccm2200/board-ccm2200.c
--- linux-orig/arch/arm/mach-at91/ccm2200/board-ccm2200.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-ccm2200/arch/arm/mach-at91/ccm2200/board-ccm2200.c	2015-06-18 10:41:42.000000000 +0200
@@ -0,0 +1,578 @@
+/*
+ * linux/arch/arm/mach-at91rm9200/board-ccm2200.c
+ *
+ * Copyright (C) 2006 by Weiss-Electronic GmbH.
+ * Copyright (C) 2010 by SWARCO Traffic Systems GmbH.
+ * All rights reserved.
+ *
+ * @author:     Guido Classen <guido.classen@swarco.de>
+ * @descr:      Configuation settings for the CCM2200 board.
+ * @references: [1] board-unc90.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  @par Modification History:
+ *     2006-04-24 gc: initial version (taken from board-unc90.c)
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/i2c-gpio.h>
+
+#include <asm/hardware.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/hardware.h>
+//#include <asm/mach/serial_at91rm9200.h> /* must be here, why? */
+#include <asm/arch/board.h>
+
+#include <asm/arch/at91-util.h>
+
+#include <asm/arch/gpio.h>
+#include <asm/arch/at91_pio.h>
+#include <asm/arch/at91rm9200_mc.h>
+#include <asm/arch/at91_pmc.h>
+
+
+#include <asm/arch/board-ccm2200.h>
+
+#include "../generic.h"
+
+
+
+/* //#define UART_BASE AT91RM9200_BASE_US2 */
+/* #define UART_BASE AT91_IO_P2V(AT91RM9200_BASE_US2) */
+/* #define UART_SR   (UART_BASE+0x14) */
+/* #define UART_THR   (UART_BASE+0x1c) */
+/* #include <asm/arch/at91_dbgu.h> */
+
+/* static void putc(int c) */
+/* { */
+/* 	while (!(__raw_readl(UART_SR) & AT91_DBGU_TXRDY)) */
+/* 		barrier(); */
+/* 	__raw_writel(c, UART_THR); */
+/* } */
+/* static inline void flush(void) */
+/* { */
+/* 	/\* wait for transmission to complete *\/ */
+/* 	while (!(__raw_readl(UART_SR) & AT91_DBGU_TXEMPTY)) */
+/* 		barrier(); */
+/* } */
+/* static void putstr(const char *ptr) */
+/* { */
+/* 	char c; */
+
+/* 	while ((c = *ptr++) != '\0') { */
+/* 		if (c == '\n') */
+/* 			putc('\r'); */
+/* 		putc(c); */
+/* 	} */
+
+/* 	flush(); */
+/* } */
+
+
+static inline void dbg_led(unsigned led)
+{
+
+/*                 ldr     r0,=0xfffffa30 */
+/*                 ldr     r1,=0x0000ffff */
+/*                 str     r1,[r0] */
+/*                 ldr     r0,=0xfffffa34 */
+/*                 ldr     r1,=(1<<0) */
+/*                 str     r1,[r0] */
+/* 1:              b       1b */
+        *(volatile unsigned *)AT91_IO_P2V(0xfffffa30) = ~led & 0xffff;
+        *(volatile unsigned *)AT91_IO_P2V(0xfffffa34) = led & 0xffff;
+}
+
+static void __init ccm2200_init_irq(void)
+{
+/* 	putstr("init_irq\n"); */
+
+	/* Initialize AIC controller */
+	at91rm9200_init_interrupts(NULL);
+
+	/* Set up the GPIO interrupts (2007-02-07 gc: is this necessary???) */
+	//at91_gpio_irq_setup(BGA_GPIO_BANKS);
+}
+
+/* 
+ * Configure the static memory controller chip select register using
+ * values in struct at91_smc_cs_info
+ */
+int at91_config_smc_cs( register const struct at91_smc_cs_info *info )
+{
+  unsigned int mask;
+
+  /* use #if 0 to disable memory controller reprogramming in kernel */
+#if 1
+        /* check parameters */
+        if ( info->chip_select < 0 || info->chip_select > 7 
+             || info->wait_states < 0 || info->wait_states > 128  
+             || info->data_float_time < 0 || info->data_float_time > 15
+             || (info->byte_access_type != AT91_BAT_TWO_8_BIT
+                 && info->byte_access_type != AT91_BAT_16_BIT)
+             || (info->data_read_protocol != AT91_DRP_STANDARD
+                 && info->data_read_protocol != AT91_DRP_EARLY)
+             || info->address_to_cs_setup < AT91_ACSS_STANDARD
+             || info->address_to_cs_setup > AT91_ACSS_3_CYCLES
+             || info->rw_setup < 0 || info->rw_setup > 7
+             || info->rw_hold  < 0 || info->rw_hold > 7)
+        {
+                return -1;
+        }
+
+        // configure gpios, if necessary
+        if( info->chip_select > 3 )
+        {
+#define AT91C_PC10_NCS4_CFCS  (1<<10)
+#define AT91C_PC11_NCS5_CFCE1 (1<<11)
+#define AT91C_PC12_NCS6_CFCE2 (1<<12)
+#define AT91C_PC13_NCS7	      (1<<13)
+                switch( info->chip_select )
+                {
+                case 4:	mask = AT91C_PC10_NCS4_CFCS;	break;
+                case 5:	mask = AT91C_PC11_NCS5_CFCE1;	break;
+                case 6:	mask = AT91C_PC12_NCS6_CFCE2;	break;
+                case 7:	mask = AT91C_PC13_NCS7;		break;
+                default: mask = 0;
+                }
+                /* select peripheral a function */
+                //AT91_SYS->PIOC_ASR = mask;
+                at91_sys_write(AT91_PIOC + PIO_ASR, mask);
+
+                /* disable pio controller and enable peripheral */
+                //AT91_SYS->PIOC_PDR = mask;
+                at91_sys_write(AT91_PIOC + PIO_PDR, mask);
+        }
+
+        /* write the new configuration to SMC chip select register */
+	at91_sys_write(AT91_SMC_CSR(info->chip_select), 
+                       (info->wait_states > 0 
+                        ? (AT91_SMC_NWS & (info->wait_states-1)) 
+                        | AT91_SMC_WSEN
+                        : 0)
+                       | (info->data_float_time << 8) 
+                       | (info->byte_access_type == AT91_BAT_16_BIT
+                   ? AT91_SMC_BAT : 0) 
+                | ((int)info->data_bus_width << 13) 
+                | (info->data_read_protocol == AT91_DRP_EARLY 
+                   ? AT91_SMC_DPR : 0) 
+                | ((int)info->address_to_cs_setup << 16)
+                | (info->rw_setup << 24)
+                | (info->rw_hold  << 28)
+                );
+#else
+
+  printk(KERN_WARNING "CCM2200 at91_config_smc_cs(cs=%d): "
+         "NOT reprogramming memory controller (DISABLED)\n",
+         info->chip_select);
+
+#endif
+        return 0;
+}
+
+EXPORT_SYMBOL( at91_config_smc_cs );
+
+
+/* Macros for PLL setup (maybe to hardware.h) */
+#define AT91_PLL_VALUE_FAST(div,mult)	((div) | (1024 << 8) | ((mult-1) << 16) | (1 << 15) | (1 << 29))
+#define AT91_PLLB_VALUE_USB(div,mult)	((div) | (63 << 8) | ((mult-1) << 16) | (1 << 28))
+
+
+#define AT91_SLOW_CLOCK         32768
+#define AT91_MAIN_CLOCK         18432000
+static void measure_and_set_clocks(void)
+{
+	unsigned long mainf_counter = at91_sys_read(AT91_CKGR_MCFR) & AT91_PMC_MAINF;
+	unsigned long main_clock = mainf_counter * (AT91_SLOW_CLOCK / 16);
+	unsigned long main_clock_measured;
+	unsigned long plla_clock;
+	unsigned long pllb_clock;
+
+	unsigned long master_clock;
+	unsigned long cpu_clock;
+
+	main_clock_measured = main_clock;
+
+	if (main_clock_measured > (unsigned long) (AT91_MAIN_CLOCK * 0.99)
+	    && main_clock_measured < (unsigned long) (AT91_MAIN_CLOCK * 1.01)) {
+	    main_clock = AT91_MAIN_CLOCK;
+	}
+
+
+	{
+			unsigned div_a = at91_sys_read(AT91_CKGR_PLLAR) & AT91_PMC_DIV;
+			unsigned mul_a = (at91_sys_read(AT91_CKGR_PLLAR) & AT91_PMC_MUL) >> 16;
+			
+			if (div_a == 0 || mul_a == 0) {
+				plla_clock = 0;
+			} else {
+				plla_clock = (((unsigned /*long*/ long) main_clock)
+					      *  (mul_a+1) / div_a);
+			}
+	}
+			
+	{
+                unsigned div_b = at91_sys_read(AT91_CKGR_PLLBR) & AT91_PMC_DIV;
+                unsigned mul_b = (at91_sys_read(AT91_CKGR_PLLBR) & AT91_PMC_MUL) >> 16;
+		
+		if (div_b == 0 || mul_b == 0) {
+			pllb_clock = 0;
+		} else {
+			pllb_clock = (((unsigned /*long*/ long) main_clock)
+				      *  (mul_b+1) / div_b);
+		}
+	}
+
+	switch (at91_sys_read(AT91_PMC_MCKR) & AT91_PMC_CSS) {
+	case AT91_PMC_CSS_SLOW:
+		master_clock = AT91_SLOW_CLOCK;
+		break;
+
+	case AT91_PMC_CSS_MAIN:
+		master_clock = main_clock;
+		break;
+
+	case AT91_PMC_CSS_PLLA:
+		master_clock = plla_clock;
+		break;
+
+	case AT91_PMC_CSS_PLLB:
+		master_clock = pllb_clock;
+		break;
+
+	default:
+		master_clock = 0;
+	}
+
+
+	switch (at91_sys_read(AT91_PMC_MCKR) & AT91_PMC_PRES) {
+	default:
+	case AT91_PMC_PRES_1:
+		break;
+	case AT91_PMC_PRES_2:
+		master_clock >>= 1;
+		break;
+
+	case AT91_PMC_PRES_4:
+		master_clock >>= 2;
+		break;
+
+	case AT91_PMC_PRES_8:
+		master_clock >>= 3;
+		break;
+
+	case AT91_PMC_PRES_16:
+		master_clock >>= 4;
+		break;
+
+	case AT91_PMC_PRES_32:
+		master_clock >>= 5;
+		break;
+
+	case AT91_PMC_PRES_64:
+		master_clock >>= 6;
+		break;
+	}
+
+	cpu_clock = master_clock;
+
+	switch (at91_sys_read(AT91_PMC_MCKR) & AT91_PMC_MDIV) {
+	default:
+	case AT91_PMC_MDIV_1:
+		break;
+
+	case AT91_PMC_MDIV_2:
+		master_clock >>= 1;
+		break;
+
+	case AT91_PMC_MDIV_3:
+		master_clock /= 3;
+		break;
+
+	case AT91_PMC_MDIV_4:
+		master_clock >>= 2;
+		break;
+	}
+
+  /* 2006-10-17 gc: save measured clock values in global variables */
+//  at91_master_clock = master_clock;
+//  at91_main_clock   = cpu_clock;
+
+  printk("CCM2200 Main   Clock: %9lu Hz (measured: %9lu Hz)\n", 
+	 main_clock, main_clock_measured);
+  printk("        PLLA   Clock: %9lu Hz\n", plla_clock);
+  printk("        PLLB   Clock: %9lu Hz\n", pllb_clock);
+  printk("        CPU    Clock: %9lu Hz\n", cpu_clock);
+  printk("        Master Clock: %9lu Hz\n", master_clock);
+  printk("Kernel timer frequency: %6u HZ\n", (unsigned) HZ);
+
+}
+
+static void __init ccm2200_map_io(void)
+{
+/* 	putstr("map_io\n"); */
+
+	//at91rm9200_map_io();
+
+        /* 2006-04-28 gc: kernel will not reprogramm clocks yet, they are 
+         * initialized only by the bootloader!
+         *
+         * 2006-10-17 gc: use messure_and_set_clocks() instead of hard coded
+	 *                clock values
+	 */
+	//at91_pllb_clock = AT91_PLLB_VALUE_USB(14, 73);	// (18.432 / 14 * 73) /2 = 47.9714
+
+
+	/* Initialize processor: 18.432 MHz crystal */
+	at91rm9200_initialize(18432000, AT91RM9200_BGA);
+
+	/* Setup the LEDs */
+	//at91_init_leds(AT91_PIN_PB2, AT91_PIN_PB2);
+
+	//measure_and_set_clocks();
+
+        /* early initialization to use AT91 UART as serial console!  */
+        //dbg_led(1<<5);
+        ccm2200_at91_uart_init();
+        //dbg_led(1<<8);
+
+	/* Setup the LEDs */
+	at91_init_leds(AT91_PIN_PD10, AT91_PIN_PD11);
+
+}
+
+static struct at91_eth_data __initdata ccm2200_eth_data = {
+	.phy_irq_pin	= AT91_PIN_PC4,
+	.is_rmii	= 0,
+};
+
+
+#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
+static struct at91_usbh_data __initdata ccm2200_usbh_data = {
+	.ports		= 2,
+};
+#endif
+
+
+#if defined(CONFIG_USB_GADGET_AT91)
+static struct at91_udc_data __initdata ccm2200_udc_data = {
+/* 	.vbus_pin	= -1,	/\* Not used on CCM2200 *\/ */
+        /* 
+         * 2010-06-09 gc: 
+         * We use the SCONF3 signal. This signal can be accessed on
+         * DIP-Switch 8
+         */
+	.pullup_pin	= AT91_PIN_PB28,
+};
+#endif
+
+static struct spi_board_info ccm2200_spi_devices[] = {
+	{ /* User accessable spi - cs0 (10Mhz) */
+		.modalias = "spi-cs0",
+		.chip_select  = 0,
+		.max_speed_hz = 10 * 1000 * 1000,
+	},
+	{ /* User accessable spi - cs1 (250KHz) */
+		.modalias = "spi-cs1",
+		.chip_select  = 1,
+		.max_speed_hz = 250 *  1000,
+	},
+	{ /* User accessable spi - cs2 (1MHz) */
+		.modalias = "spi-cs2",
+		.chip_select  = 2,
+		.max_speed_hz = 1 * 1000 *  1000,
+	},
+	{ /* User accessable spi - cs3 (10MHz) */
+		.modalias = "spi-cs3",
+		.chip_select  = 3,
+		.max_speed_hz = 10 * 1000 *  1000,
+	},
+};
+
+#undef CCM2200_USE_AT91_LEDS
+
+#ifdef CCM2200_USE_AT91_LEDS
+
+/* 2007-09-10 gc: make usage of new Linux kernel LED framework! */
+static struct at91_gpio_led ccm2200_leds[] = {
+	{
+		.name		= "led0",
+		.gpio		= AT91_PIN_PD0,
+		//.trigger	= "heartbeat",
+	},
+	{
+		.name		= "led1",
+		.gpio		= AT91_PIN_PD1,
+		//.trigger	= "timer",
+	},
+	{
+		.name		= "led2",
+		.gpio		= AT91_PIN_PD2,
+	},
+	{
+		.name		= "led3",
+		.gpio		= AT91_PIN_PD3,
+	},
+	{
+		.name		= "led4",
+		.gpio		= AT91_PIN_PD4,
+	},
+	{
+		.name		= "led5",
+		.gpio		= AT91_PIN_PD5,
+	},
+	{
+		.name		= "led6",
+		.gpio		= AT91_PIN_PD6,
+	},
+	{
+		.name		= "led7",
+		.gpio		= AT91_PIN_PD7,
+	},
+	{
+		.name		= "led8",
+		.gpio		= AT91_PIN_PD8,
+	},
+	{
+		.name		= "led9",
+		.gpio		= AT91_PIN_PD9,
+	},
+	{
+		.name		= "led10",
+		.gpio		= AT91_PIN_PD10,
+	},
+	{
+		.name		= "led11",
+		.gpio		= AT91_PIN_PD11,
+	},
+	{
+		.name		= "led12",
+		.gpio		= AT91_PIN_PD12,
+	},
+	{
+		.name		= "led13",
+		.gpio		= AT91_PIN_PD13,
+	},
+	{
+		.name		= "led14",
+		.gpio		= AT91_PIN_PD14,
+	},
+	{
+		.name		= "led15",
+		.gpio		= AT91_PIN_PD15,
+	}
+};
+
+#else
+static struct platform_device ccm2200_leds = {
+	.name		= "ccm2200_leds",
+	.id		= -1,
+};
+#endif
+
+
+static struct i2c_gpio_platform_data ccm2200_i2c_gpio_data = {
+     .sda_pin    = AT91_PIN_PA25,
+     .scl_pin    = AT91_PIN_PA26,
+};
+
+static struct platform_device ccm2200_i2c_gpio_controller = {
+     .name       = "i2c-gpio",
+     .id     = 0,
+     .dev        = {
+         .platform_data  = &ccm2200_i2c_gpio_data,
+     },
+};
+
+static void ccm2200_add_device_soft_i2c(void)
+{
+        /* i2c GPIO bit bang */
+        at91_set_gpio_input(ccm2200_i2c_gpio_data.sda_pin, 1);
+        at91_set_gpio_input(ccm2200_i2c_gpio_data.scl_pin, 1);
+        platform_device_register(&ccm2200_i2c_gpio_controller);
+}
+
+
+static void __init ccm2200_board_init(void)
+{
+/* 	putstr("board_init\n"); */
+
+        //ccm2200_set_frontpanel_leds(1<<0, 0xffff);
+	/* Serial */
+	at91_add_device_serial();
+	/* Ethernet */
+	at91_add_device_eth(&ccm2200_eth_data);
+
+#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
+	/* USB Host */
+	at91_add_device_usbh(&ccm2200_usbh_data);
+#endif
+
+#if defined(CONFIG_USB_GADGET_AT91)
+	/* USB Device */
+	at91_add_device_udc(&ccm2200_udc_data);
+#endif
+
+	/* I2C */
+        /* 2007-11-13 gc: use software (bit bang) i2c, because hardware
+         * two wire controler on AT91RM9200 dosn't work reliable!
+         */
+	/* at91_add_device_i2c(); */
+        ccm2200_add_device_soft_i2c();
+
+	/* SPI */
+	at91_add_device_spi(ccm2200_spi_devices, 
+			    ARRAY_SIZE(ccm2200_spi_devices));
+
+        /* 2007-09-10 gc: LEDs: standard Linux LED driver */
+#ifdef CCM2200_USE_AT91_LEDS
+	at91_gpio_leds(ccm2200_leds, ARRAY_SIZE(ccm2200_leds));
+#else
+	platform_device_register(&ccm2200_leds);
+#endif
+
+}
+
+MACHINE_START(CCM2200, "CCM2200")
+	.phys_io	= AT91_BASE_SYS,
+	.io_pg_offst	= (AT91_VA_BASE_SYS >> 18) & 0xfffc,
+	.boot_params	= AT91_SDRAM_BASE + 0x100,
+	.timer	= &at91rm9200_timer,
+
+	.map_io		= ccm2200_map_io,
+	.init_irq	= ccm2200_init_irq,
+	.init_machine	= ccm2200_board_init,
+MACHINE_END
+
+
+/*
+ *Local Variables:
+ * mode: c
+ * c-file-style: "linux"
+ * End:
+ */
diff -Nrub '--exclude=*~' linux-orig/arch/arm/mach-at91/ccm2200/Makefile linux-2.6.21-ccm2200/arch/arm/mach-at91/ccm2200/Makefile
--- linux-orig/arch/arm/mach-at91/ccm2200/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-ccm2200/arch/arm/mach-at91/ccm2200/Makefile	2015-06-18 10:41:42.000000000 +0200
@@ -0,0 +1,12 @@
+#
+# Makefile for CCM2200 board support
+#
+
+
+# Board-specific support
+obj-$(CONFIG_MACH_CCM2200)      += ccm2200.o
+
+ccm2200-objs			 = board-ccm2200.o		\
+				   at91-uart-ccm2200.o		\
+				   quad-uart-ccm2200.o		\
+				   serial-ccm2200.o		\
diff -Nrub '--exclude=*~' linux-orig/arch/arm/mach-at91/ccm2200/quad-uart-ccm2200.c linux-2.6.21-ccm2200/arch/arm/mach-at91/ccm2200/quad-uart-ccm2200.c
--- linux-orig/arch/arm/mach-at91/ccm2200/quad-uart-ccm2200.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-ccm2200/arch/arm/mach-at91/ccm2200/quad-uart-ccm2200.c	2015-06-18 10:41:42.000000000 +0200
@@ -0,0 +1,258 @@
+/*
+ * linux/arch/arm/mach-at91rm9200/quad-uart-ccm2200.c
+ *
+ * Copyright (C) 2006 by Weiss-Electronic GmbH.
+ * Copyright (C) 2010 by SWARCO Traffic Systems GmbH.
+ * All rights reserved.
+ *
+ * @author:     Guido Classen <guido.classen@swarco.de>
+ * @descr:      Support for external Quad UART SC16C754 on CCM2200 board.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  @par Modification History:
+ *     2006-04-29 gc: removed wrong AT91C_ID_IRQ0 in ds1337.c, now we have it
+ *     2006-04-28 gc: initial version (partly derived from mach-a9m2410.c
+ *                    written by Jonas Dietsche, Joachim Jaeger)
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+
+
+#include <asm/hardware.h>
+#include <asm/setup.h>
+#include <asm/irq.h>
+
+
+#include <asm/io.h>		/* ioremap */
+#include <asm/arch/hardware.h>
+#include <asm/arch/board.h>
+#include <asm/arch/at91-util.h>
+#include <asm/arch/board-ccm2200.h>
+
+#include <linux/serial_core.h>
+#include <linux/serial_8250.h>
+#include <asm/arch/irqs.h>
+#include <asm/hardware.h>
+#include <asm/arch/at91_pmc.h>
+#include <asm/arch/gpio.h>
+
+#include <linux/clk.h>          /* clk_get */
+
+
+static struct 
+plat_serial8250_port serial_platform_data[CCM2200_QUAD_UART_NUM_PORTS+1];
+static struct platform_device serial_device = {
+        .name			= "serial8250",
+        .id			= 0,
+        .dev			= {
+                .platform_data	= serial_platform_data,
+        }
+};
+
+
+
+#ifndef CONFIG_AT91_PROGRAMMABLE_CLOCKS
+
+/** 2006-04-28 gc: configure an at91rm9200 programable clock output 
+ * <br>
+ * @param pck_number    number of pck pin (0...3 for AT91RM9200)
+ * @return              Errorcode: 
+ *                        0  ok (Service terminated)
+ *                        -1 error occurred
+ */
+enum at91rm9200_clock_source {
+        AT91RM9200_SLOW_CLOCK = 0,
+        AT91RM9200_MAIN_CLOCK = 1,
+        AT91RM9200_PLLA_CLOCK = 2,
+        AT91RM9200_PLLB_CLOCK = 3
+};
+
+enum at91rm9200_pck_prescaler {
+        PCK_SELECTED_CLOCK = 0,
+        PCK_SELECTED_CLOCK_DIV_2 = 1,
+        PCK_SELECTED_CLOCK_DIV_4 = 2,
+        PCK_SELECTED_CLOCK_DIV_8 = 3,
+        PCK_SELECTED_CLOCK_DIV_16 = 4,
+        PCK_SELECTED_CLOCK_DIV_32 = 5,
+        PCK_SELECTED_CLOCK_DIV_64 = 6
+};
+
+int at91rm9200_config_prg_clk_generator(int pck_number,
+                                        enum at91rm9200_clock_source source,
+                                        enum at91rm9200_pck_prescaler prescaler)
+{
+        /* program source and prescaler */
+        //AT91_SYS->PMC_PCKR[pck_number] = source | (prescaler << 2);
+        at91_sys_write(AT91_PMC_PCKR(pck_number), source | (prescaler << 2));
+  
+        /* enable programmable Clock Output */
+        switch (pck_number) {
+#define		AT91_PMC_PCK4		(1 << 12)		/* Programmable Clock 4 */
+#define		AT91_PMC_PCK5		(1 << 13)		/* Programmable Clock 5 */
+#define		AT91_PMC_PCK6		(1 << 14)		/* Programmable Clock 6 */
+#define		AT91_PMC_PCK7		(1 << 15)		/* Programmable Clock 7 */
+
+        case 0: at91_sys_write(AT91_PMC_SCER, AT91_PMC_PCK0); break;
+        case 1: at91_sys_write(AT91_PMC_SCER, AT91_PMC_PCK1); break;
+        case 2: at91_sys_write(AT91_PMC_SCER, AT91_PMC_PCK2); break;
+        case 3: at91_sys_write(AT91_PMC_SCER, AT91_PMC_PCK3); break;
+        case 4: at91_sys_write(AT91_PMC_SCER, AT91_PMC_PCK4); break;
+        case 5: at91_sys_write(AT91_PMC_SCER, AT91_PMC_PCK5); break;
+        case 6: at91_sys_write(AT91_PMC_SCER, AT91_PMC_PCK6); break;
+        case 7: at91_sys_write(AT91_PMC_SCER, AT91_PMC_PCK7); break;
+        }
+        return 0;
+}
+
+#endif
+
+static int __init ccm2200_quad_uart_init(void) 
+{
+	void __iomem *quad_uart_virt_base;
+        struct plat_serial8250_port *port_iter;
+        int i;
+
+        /*
+         * Setup static memory controller chip select for external quad UART
+         *
+         */
+        static const struct __initdata at91_smc_cs_info quad_uart_cs_config = {
+                .chip_select          = CCM2200_QUAD_UART_CS,
+                .wait_states          = 16,
+                .data_float_time      = 0,
+                .byte_access_type     = AT91_BAT_8_BIT,
+                .data_bus_width       = AT91_DATA_BUS_WIDTH_8,
+                .data_read_protocol   = AT91_DRP_STANDARD,
+                .address_to_cs_setup  = AT91_ACSS_STANDARD,
+                .rw_setup             = 2,
+                .rw_hold              = 2
+        };
+
+        if ( at91_config_smc_cs( &quad_uart_cs_config ) != 0 ) {
+                printk( KERN_ERR 
+                        "Unable to configure external quad UART chip select "
+                        "signal\n" );
+                return -EIO;
+	}
+
+	quad_uart_virt_base = ioremap_nocache( CCM2200_QUAD_UART_PHYS, 
+                                               CCM2200_QUAD_UART_SIZE);
+	if (!quad_uart_virt_base ) {
+		printk( "ioremap CCM2200 quad UART failed\n" );
+		return -EIO;
+	}
+
+        memset(serial_platform_data, 0, sizeof(serial_platform_data));
+        /* insert virtual base address in serial_platform_data */
+        for (port_iter = serial_platform_data, i = 0;
+             i < CCM2200_QUAD_UART_NUM_PORTS;
+             ++port_iter, ++i) {
+                port_iter->membase      = quad_uart_virt_base
+                        + i * CCM2200_QUAD_UART_PORT_OFFSET;
+                
+                port_iter->iobase       = (unsigned) port_iter->membase;
+                port_iter->mapbase      = (unsigned) port_iter->membase;
+                port_iter->irq          = CCM2200_QUAD_UART_IRQ;
+                port_iter->iotype       = UPIO_MEM;
+                port_iter->uartclk      = CCM2200_QUAD_UART_CLOCK_RATE;
+                port_iter->regshift     = 0;
+                port_iter->flags        = UPF_BOOT_AUTOCONF;
+        }
+
+        /* configure 18.432 MHz crystal main clock divided by 2 for
+         * UART over PCK1 */
+#ifdef CONFIG_AT91_PROGRAMMABLE_CLOCKS
+        /* 2007-06-12 gc: Support for "A91 Programmable Clocks" feature
+         * in Kernels since 2.6.21.
+         * Subject for testing! Then remove old code!
+         */
+        {
+                struct clk *clk_pck1 = clk_get(NULL, "pck1");
+                struct clk *clk_main = clk_get(NULL, "main");
+                if (!clk_pck1 || !clk_main) {
+                        printk("ERROR getting PCK1 or Main clock sources\n");
+                        return -EIO;
+                } else {
+
+                        clk_set_parent(clk_pck1, clk_main);
+                        clk_set_rate(clk_pck1, CCM2200_QUAD_UART_CLOCK_RATE);
+                        clk_enable(clk_pck1);
+                }
+        }
+
+
+#else
+        at91rm9200_config_prg_clk_generator(1,
+                                            AT91RM9200_MAIN_CLOCK,
+                                            //PCK_SELECTED_CLOCK
+                                            // 2006-06-26 gc:
+                                            // we must use a divider of 2 here
+                                            // on account of EMI....
+                                            PCK_SELECTED_CLOCK_DIV_2
+                );
+#endif /* CONFIG_AT91_PROGRAMMABLE_CLOCKS */
+
+
+        /* switch gpio PIN to the PCK1 output */
+        at91_set_B_periph(CCM2200_PIN_PCK1_UART_CLOCK, GPIO_NO_PULLUP);
+        /* reset UART */
+        gpio_direction_output(CCM2200_PIN_UART_RESET, GPIO_INIT_1);
+        udelay(10);
+        at91_set_gpio_value(CCM2200_PIN_UART_RESET, 0);
+
+        /* initialize IRQ0 pin */
+        gpio_direction_input(CCM2200_PIN_UART_IRQ);
+        at91_set_deglitch(CCM2200_PIN_UART_IRQ, 1);
+
+        /* testweise */
+	at91_set_A_periph(CCM2200_PIN_UART_IRQ, 1);
+        at91_set_gpio_input(CCM2200_PIN_UART_IRQ, 1);
+        at91_set_deglitch(CCM2200_PIN_UART_IRQ, 1);
+
+	set_irq_type(CCM2200_QUAD_UART_IRQ, IRQT_HIGH);
+/* 	set_irq_type(CCM2200_QUAD_UART_IRQ, IRQT_RISING); */
+
+	platform_device_register(&serial_device);
+        printk( "CCM2200 SC16C754 quad UART successfully initialized\n" );
+
+        return 0;
+}
+
+
+static void __exit ccm2200_quad_uart_exit(void)
+{
+}
+
+module_init(ccm2200_quad_uart_init);
+module_exit(ccm2200_quad_uart_exit);
+
+MODULE_AUTHOR("Guido Classen");
+MODULE_DESCRIPTION("CCM2200 external quad UART configuration");
+MODULE_LICENSE("GPL");
+
+/*
+ *Local Variables:
+ * mode: c
+ * c-file-style: "linux"
+ * End:
+ */
diff -Nrub '--exclude=*~' linux-orig/arch/arm/mach-at91/ccm2200/serial-ccm2200.c linux-2.6.21-ccm2200/arch/arm/mach-at91/ccm2200/serial-ccm2200.c
--- linux-orig/arch/arm/mach-at91/ccm2200/serial-ccm2200.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-ccm2200/arch/arm/mach-at91/ccm2200/serial-ccm2200.c	2015-06-18 10:41:42.000000000 +0200
@@ -0,0 +1,734 @@
+/*
+ * linux/arch/arm/mach-at91rm9200/serial-ccm2200.c
+ *
+ * Copyright (C) 2007 by Weiss-Electronic GmbH.
+ * Copyright (C) 2010 by SWARCO Traffic Systems GmbH.
+ * All rights reserved.
+ *
+ * @author:     Guido Classen <guido.classen@swarco.de>
+ * @descr:      CCM2200 Board specific serial port functions
+ *              (LED and RS485 support)
+ * @references:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  @par Modification History:
+ *     2007-02-01 gc: initial version
+ */
+
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/serial_core.h>
+#include <linux/ccm2200_serial.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/uaccess.h>		/* copy_to_user */
+#include "../../../../drivers/serial/atmel_serial.h"
+#include <asm/arch/board.h>
+
+#include <asm/arch/board-ccm2200.h>
+
+
+#define LED_INTERVAL   msecs_to_jiffies(30)
+static void ccm2200_board_serial_led_stop(struct ccm2200_led_handler *led);
+static int ccm2200_board_serial_ioctl_set_led(struct ccm2200_led_handler *led,
+                                              unsigned long arg);
+static void ccm2200_board_serial_turn_on_off_timer_handler(unsigned long data);
+
+/******************************************************************************
+ * CCM2200 RS485 piggyback support
+ *****************************************************************************/
+
+#define UART_PUT_CR(port,v)	__raw_writel(v, (port)->membase + ATMEL_US_CR)
+#define UART_GET_MR(port)	__raw_readl((port)->membase + ATMEL_US_MR)
+#define UART_PUT_MR(port,v)	__raw_writel(v, (port)->membase + ATMEL_US_MR)
+
+/* turn on piggyback RS485 transmitter */
+static inline
+void ccm2200_board_serial_turn_on(register struct uart_port *port)
+{
+        register struct ccm2200_board_serial *se = port->ccm2200_serial;
+        struct uart_info *info = port->info;
+        if (se->conf.mode != CCM2200_SERIAL_MODE_RS485KERN_NEG) {
+          se->orig_ops->set_mctrl(port, TIOCM_RTS | port->mctrl);
+        } else {
+          se->orig_ops->set_mctrl(port, ~TIOCM_RTS & port->mctrl);
+        }
+        /* wait for CTS in send mode */
+/*         info->flags |= UIF_CTS_FLOW; */
+}
+
+/* turn off piggyback RS485 transmitter */
+static inline
+void ccm2200_board_serial_turn_off(register struct uart_port *port)
+{
+        register struct ccm2200_board_serial *se = port->ccm2200_serial;
+        struct uart_info *info = port->info;
+
+        /* ignore CTS in receive mode */
+        info->flags &= ~UIF_CTS_FLOW & ~UIF_CHECK_CD;
+        info->tty->hw_stopped = 0;
+
+        if (se->conf.mode != CCM2200_SERIAL_MODE_RS485KERN_NEG) {
+          se->orig_ops->set_mctrl(port, ~TIOCM_RTS & port->mctrl);
+        } else {
+          se->orig_ops->set_mctrl(port, TIOCM_RTS | port->mctrl);
+        }
+        se->state = CCM2200_BS_RECEIVE;
+}
+
+
+static void ccm2200_board_serial_at91_rs485_mode(struct uart_port *port,
+                                                int enable)
+{
+        unsigned mode = UART_GET_MR(port);
+
+        mode &= ~ATMEL_US_USMODE;
+        if (enable) {
+                mode |= ATMEL_US_USMODE_RS485;
+        } else {
+                mode |= ATMEL_US_USMODE_NORMAL;
+        }
+        UART_PUT_MR(port, mode);
+	UART_PUT_CR(port, ATMEL_US_RSTSTA | ATMEL_US_RSTRX);
+	UART_PUT_CR(port, ATMEL_US_TXEN | ATMEL_US_RXEN);
+}
+
+
+
+static
+int ccm2200_board_serial_chg_conf(struct uart_port *port,
+                                  struct ccm2200_serial_config *new_conf)
+{
+        register struct ccm2200_board_serial *se = port->ccm2200_serial;
+
+        if (new_conf->mode != se->conf.mode) {
+                /* mode was changed */
+
+                /* switch of HW RS485 mode if previously enabled */
+                if (se->conf.mode == CCM2200_SERIAL_MODE_RS485HW)
+                        ccm2200_board_serial_at91_rs485_mode(port, 0);
+
+                switch (new_conf->mode) {
+                case CCM2200_SERIAL_MODE_NORMAL:
+                        if (new_conf->turn_on_delay != 0 ||
+                            new_conf->turn_off_delay != 0) {
+                                /* turn on/off delay not support in this mode*/
+                                return -EINVAL;
+                        }
+                        break;
+
+                case CCM2200_SERIAL_MODE_RS485HW: {
+                        /* this mode is only supported on ports from
+                         * ATMEL AT91 UART */
+                        struct tty_driver *driver = port->info->tty->driver;
+                        if (new_conf->turn_on_delay != 0 ||
+                            new_conf->turn_off_delay != 0) {
+                                /* turn on/off delay not support in this mode*/
+                                return -EINVAL;
+                        }
+                        if (!strcmp(driver->driver_name, "ttyS")
+                            || !strcmp(driver->driver_name, "at91")
+                            || !strcmp(driver->driver_name, "atmel_serial")) {
+
+                                ccm2200_board_serial_at91_rs485_mode(port, 1);
+
+                                break;
+
+                        } else {
+                                printk(KERN_WARNING
+                                       "CCM2200_SERIAL_MODE_RS485HW "
+                                       "not supported on "
+                                       "this device, using "
+                                       "CCM2200_SERIAL_MODE_RS485KERN\n");
+                                new_conf->mode =
+                                        CCM2200_SERIAL_MODE_RS485KERN;
+                        }
+                        /* no break */
+                }
+
+                case CCM2200_SERIAL_MODE_RS485KERN:
+                case CCM2200_SERIAL_MODE_RS485KERN_NEG:
+                case CCM2200_SERIAL_MODE_MODEM_MD:
+                case CCM2200_SERIAL_MODE_MODEM_MD_DCD:
+                        /* clear RTS, it will be set from now on by sending
+                         * RS485 data
+                         */
+                        ccm2200_board_serial_turn_off(port);
+                        break;
+
+                case CCM2200_SERIAL_MODE_RS485INT:
+                        return -ENOIOCTLCMD;
+
+                default:
+                        return -EFAULT;
+                }
+        }
+
+        new_conf->turn_on_delay = msecs_to_jiffies(new_conf->turn_on_delay);
+        new_conf->turn_off_delay = msecs_to_jiffies(new_conf->turn_off_delay);
+        memcpy(&se->conf, new_conf, sizeof(se->conf));
+
+        return 0;
+}
+
+
+/* this array contains a list of all port currently sending .
+ * We wait for end of transmission and subsequently turn off RTS
+ */
+/*
+ * #define MAX_TX_PORTS    10
+ * static struct uart_port *volatile tx_ports[MAX_TX_PORTS];
+ * static volatile unsigned tx_ports_size = 0;
+ * static spinlock_t tx_ports_lock;
+ * static struct timer_list tx_timer;
+ */
+
+/*
+ * static inline void add_tx_port(struct uart_port *port)
+ * {
+ *	unsigned long flags;
+ *         unsigned old_tx_ports_size;
+ *
+ * /\*         printk("add_tx_port(%d)\n", tx_ports_size); *\/
+ *
+ *	spin_lock_irqsave(&tx_ports_lock, flags);
+ *         old_tx_ports_size = tx_ports_size;
+ *         if (tx_ports_size < MAX_TX_PORTS) {
+ *                 tx_ports[tx_ports_size++] = port;
+ *         }
+ *
+ *	spin_unlock_irqrestore(&tx_ports_lock, flags);
+ *         if (old_tx_ports_size == 0) {
+ *                 //printk("add_tx_port(add_timer)\n");
+ *                 tx_timer.expires = jiffies + 1;
+ *                 add_timer(&tx_timer);
+ *         }
+ * }
+ */
+
+static inline
+void ccm2200_board_serial_on_tx_empty(register struct uart_port *port)
+{
+        register struct ccm2200_board_serial *se = port->ccm2200_serial;
+
+/*
+  achtung Ausgabe braucht zu lange!!!
+  printk("ccm2200_board_serial_on_tx_empty(%d)\n", port->line); */
+
+        if (se->conf.turn_off_delay > 0) {
+                /* we have a configured followup delay,
+                 * so defer resetting RTS
+                 */
+                se->state = CCM2200_BS_TURN_OFF_DELAY;
+                mod_timer(&se->turn_on_off_timer,
+                          jiffies + se->conf.turn_off_delay);
+
+        } else {
+                /* no followup delay, immediately reset RTS */
+                ccm2200_board_serial_turn_off(port);
+        }
+}
+
+static
+void ccm2200_board_serial_goto_turn_on_state(struct uart_port *port)
+{
+        register struct ccm2200_board_serial *se = port->ccm2200_serial;
+
+        ccm2200_board_serial_turn_on(port);
+
+        se->state = CCM2200_BS_TURN_ON_DELAY;
+        if (se->conf.turn_on_delay > 0) {
+                /* start turn-on delay timer */
+                mod_timer(&se->turn_on_off_timer,
+                          jiffies + se->conf.turn_on_delay);
+        } else {
+                ccm2200_board_serial_turn_on_off_timer_handler(
+                  (unsigned long) port);
+        }
+}
+
+static
+void ccm2200_board_serial_change_to_transmit_state(struct uart_port *port)
+{
+  register struct ccm2200_board_serial *se = port->ccm2200_serial;
+  register struct uart_info *info = port->info;
+  se->state = CCM2200_BS_TRANSMIT;
+  /* reread current CTS status
+   *
+   * uart_handle_cts_change will call start_tx() if
+   * we are ready to send
+   */
+  info->tty->hw_stopped = 0;
+  se->orig_ops->start_tx(port);
+
+}
+
+static void ccm2200_board_serial_turn_on_off_timer_handler(unsigned long data)
+{
+        register struct uart_port *port = (struct uart_port *)data;
+        register struct ccm2200_board_serial *se = port->ccm2200_serial;
+                switch (se->state) {
+                case CCM2200_BS_DCD_WAIT: {
+                        /* wait for absent carrier detect (only
+                         * Mulit-drop modem mode) */
+                        if ((se->orig_ops->get_mctrl(port) & TIOCM_CD) == 0) {
+                                ccm2200_board_serial_goto_turn_on_state(port);
+                        } else {
+                                mod_timer(&se->turn_on_off_timer, jiffies + 1);
+                        }
+                        return;
+                }
+
+                case CCM2200_BS_TURN_ON_DELAY:
+/*                         printk("turn on timer expired\n"); */
+
+                  if (se->conf.mode == CCM2200_SERIAL_MODE_RS485KERN
+                      || se->conf.mode == CCM2200_SERIAL_MODE_RS485KERN_NEG) {
+                    ccm2200_board_serial_change_to_transmit_state(port);
+                    return;
+                  } else {
+
+                    se->state = CCM2200_BS_CTS_WAIT;
+                  }
+                    /* no break */
+
+                case CCM2200_BS_CTS_WAIT: {
+                        /* wait for CTS control signal */
+
+                        struct uart_info *info = port->info;
+                        if (se->orig_ops->get_mctrl(port) & TIOCM_CTS) {
+                                //port->ops->enable_ms(port);
+                          ccm2200_board_serial_change_to_transmit_state(port);
+                          return;
+/*                         uart_handle_cts_change(port, */
+/*                                                port->ops->get_mctrl(port) */
+/*                                                & TIOCM_CTS); */
+                        } else {
+                                mod_timer(&se->turn_on_off_timer, jiffies + 1);
+                        }
+                        return;
+                }
+
+
+                case CCM2200_BS_TURN_OFF_DELAY:
+                        se->state = CCM2200_BS_TRANSMIT;
+                        ccm2200_board_serial_turn_off(port);
+                        return;
+
+                case CCM2200_BS_RECEIVE:
+                        break;
+
+                case CCM2200_BS_TRANSMIT:
+                        if (!port->info->tty->hw_stopped
+                            && port->ops->tx_empty(port) != 0) {
+                                ccm2200_board_serial_on_tx_empty(port);
+                        } else {
+                                mod_timer(&se->turn_on_off_timer, jiffies + 1);
+                        }
+                        break;
+
+                default:
+                        ;
+        }
+
+}
+
+void ccm2200_board_serial_rs485_tx(struct uart_port *port)
+{
+        register struct ccm2200_board_serial *se = port->ccm2200_serial;
+
+        switch (se->conf.mode) {
+        case CCM2200_SERIAL_MODE_RS485KERN:
+        case CCM2200_SERIAL_MODE_RS485KERN_NEG:
+        case CCM2200_SERIAL_MODE_MODEM_MD:
+        case CCM2200_SERIAL_MODE_MODEM_MD_DCD:
+
+
+/*                 printk("rs485_tx\n"); */
+
+          /* add to timer list to check for transmitter empty */
+          //add_tx_port(port);
+
+          se->state = CCM2200_BS_TRANSMIT;
+          mod_timer(&se->turn_on_off_timer, jiffies + 1);
+
+        default:
+          ;
+        }
+}
+
+
+
+/* uart_ops hook / filter functions */
+static
+void ccm2200_board_serial_start_tx(struct uart_port *port)
+{
+        register struct ccm2200_board_serial *se = port->ccm2200_serial;
+        if (se->conf.mode == CCM2200_SERIAL_MODE_RS485KERN
+            || se->conf.mode == CCM2200_SERIAL_MODE_RS485KERN_NEG
+            || se->conf.mode == CCM2200_SERIAL_MODE_MODEM_MD
+            || se->conf.mode == CCM2200_SERIAL_MODE_MODEM_MD_DCD) {
+/*                 printk("ccm2200_board_serial_start_tx(%d) state=%d\n",  */
+/*                        port->line, */
+/*                        se->state); */
+
+                switch (se->state) {
+                case CCM2200_BS_RECEIVE: {
+                        struct uart_info *info = port->info;
+                        if (se->conf.mode == CCM2200_SERIAL_MODE_MODEM_MD_DCD) {
+                                struct uart_info *info = port->info;
+                                se->state = CCM2200_BS_DCD_WAIT;
+
+                                /* stop transmitter */
+                                info->tty->hw_stopped = 1;
+                                se->orig_ops->stop_tx(port);
+                                ccm2200_board_serial_turn_on_off_timer_handler(
+                                        (unsigned long) port);
+                                break;
+
+                        } else {
+                                ccm2200_board_serial_goto_turn_on_state(port);
+                                return;
+                        }
+                }
+
+                case CCM2200_BS_TURN_ON_DELAY:
+                        return;  /* wait for timer */
+
+
+                case CCM2200_BS_TURN_OFF_DELAY:
+                        del_timer_sync(&se->turn_on_off_timer);
+                        se->state = CCM2200_BS_TRANSMIT;
+                        break;
+
+                case CCM2200_BS_TRANSMIT:
+                        break;
+
+                default:
+                        ;
+                }
+        }
+        se->orig_ops->start_tx(port);
+}
+
+static
+void ccm2200_board_serial_stop_tx(struct uart_port *port)
+{
+        register struct ccm2200_board_serial *se = port->ccm2200_serial;
+/*         printk("ccm2200_board_serial_stop_tx(%d)\n", port->line); */
+        se->orig_ops->stop_tx(port);
+        if (se->conf.mode == CCM2200_SERIAL_MODE_RS485KERN
+            || se->conf.mode == CCM2200_SERIAL_MODE_RS485KERN_NEG
+            || se->conf.mode == CCM2200_SERIAL_MODE_MODEM_MD
+            || se->conf.mode == CCM2200_SERIAL_MODE_MODEM_MD_DCD) {
+                ccm2200_board_serial_turn_off(port);
+        }
+}
+
+
+static
+void ccm2200_board_serial_set_mctrl(struct uart_port *port,
+                                    unsigned int mctrl)
+{
+        register struct ccm2200_board_serial *se = port->ccm2200_serial;
+        if (se->conf.mode == CCM2200_SERIAL_MODE_RS485KERN
+            || se->conf.mode == CCM2200_SERIAL_MODE_MODEM_MD
+            || se->conf.mode == CCM2200_SERIAL_MODE_MODEM_MD_DCD) {
+                /* make shure application can't change our turn on signal! */
+                if (se->state == CCM2200_BS_RECEIVE)
+                        mctrl &= ~TIOCM_RTS;
+                else
+                        mctrl |= TIOCM_RTS;
+        }
+        if (se->conf.mode == CCM2200_SERIAL_MODE_RS485KERN_NEG) {
+          /* make shure application can't change our turn on signal! */
+          if (se->state == CCM2200_BS_RECEIVE)
+            mctrl |= TIOCM_RTS;
+          else
+            mctrl &= ~TIOCM_RTS;
+        }
+        se->orig_ops->set_mctrl(port, mctrl);
+}
+
+static
+void ccm2200_board_serial_set_termios(struct uart_port *port,
+                                      struct ktermios *new,
+                                      struct ktermios *old)
+{
+        register struct ccm2200_board_serial *se = port->ccm2200_serial;
+        se->orig_ops->set_termios(port, new, old);
+        if (se->conf.mode == CCM2200_SERIAL_MODE_RS485KERN
+            || se->conf.mode == CCM2200_SERIAL_MODE_RS485KERN_NEG
+            || se->conf.mode == CCM2200_SERIAL_MODE_MODEM_MD
+            || se->conf.mode == CCM2200_SERIAL_MODE_MODEM_MD_DCD) {
+                ccm2200_board_serial_turn_off(port);
+        }
+}
+
+
+int ccm2200_board_serial_startup(struct uart_port *port)
+{
+/*         printk("serial startup %d\n", port->line); */
+        return port->ccm2200_serial->orig_ops->startup(port);
+}
+
+
+/*
+ * static void ccm2200_board_serial_tx_timer_handler(unsigned long data)
+ * {
+ *         struct uart_port *volatile  *iter;
+ *	unsigned long flags;
+ *
+ *	spin_lock_irqsave(&tx_ports_lock, flags);
+ *         iter = tx_ports;
+ *         while (iter < tx_ports + tx_ports_size) {
+ *                 /\* if hw_stopped is set, we wait for CTS... *\/
+ *                 if (!(*iter)->info->tty->hw_stopped
+ *                       && (*iter)->ops->tx_empty(*iter) != 0) {
+ *                         ccm2200_board_serial_on_tx_empty(*iter);
+ *                         /\* remove from list *\/
+ *                         --tx_ports_size;
+ *                         /\* 2007-06-05 gc: bugfix: memcpy -> memmove *\/
+ *                         memmove((void*)iter, (void*)(iter+1),
+ *                                sizeof(struct uart_port *) *
+ *                                (tx_ports_size - (iter - tx_ports)));
+ *                 } else {
+ *                         ++iter;
+ *                 }
+ *         }
+ *	spin_unlock_irqrestore(&tx_ports_lock, flags);
+ *         if (tx_ports_size > 0)
+ *                 mod_timer(&tx_timer, jiffies + 1);
+ * }
+ */
+
+
+/******************************************************************************
+ * CCM2200 serial RX / TX indicator LED support
+ *****************************************************************************/
+
+static void ccm2200_board_serial_led_timer_handler(unsigned long data);
+
+static void ccm2200_board_serial_led_init(struct ccm2200_led_handler *led)
+{
+        led->led.mask = 0;
+        led->led.delay = LED_INTERVAL;
+        init_timer(&led->led_timer);
+	led->led_timer.function = ccm2200_board_serial_led_timer_handler;
+	led->led_timer.data = (unsigned long) led;
+        led->led_timer.expires = jiffies + led->led.delay;
+
+}
+
+
+static int ccm2200_board_serial_ioctl_set_led(struct ccm2200_led_handler *led,
+                                              unsigned long arg)
+{
+        ccm2200_board_serial_led_stop(led);
+        if (copy_from_user(&led->led,
+                           (struct ccm2200_serial_led *)arg,
+                           sizeof(led->led)))
+                return -EFAULT;
+        ;
+
+        if (led->led.delay == 0) {
+                led->led.delay = LED_INTERVAL;
+        }
+        return 0;
+
+}
+
+
+static void ccm2200_board_serial_led_stop(struct ccm2200_led_handler *led)
+{
+        if (led->led.mask != 0) {
+                del_timer_sync(&led->led_timer);
+
+                /* switch off led */
+                ccm2200_set_frontpanel_leds(0, led->led.mask);
+        }
+}
+
+static void ccm2200_board_serial_led_timer_handler(unsigned long data)
+{
+        register struct ccm2200_led_handler *led
+                = (struct ccm2200_led_handler *)data;
+        /* clear led */
+        ccm2200_set_frontpanel_leds(0, led->led.mask);
+}
+
+void ccm2200_board_serial_trigger_led(struct ccm2200_led_handler *led)
+{
+        if (led->led.mask != 0 && led->led.delay != 0) {
+                /* switch on led */
+                ccm2200_set_frontpanel_leds(led->led.mask, led->led.mask);
+
+                mod_timer(&led->led_timer, jiffies + led->led.delay);
+        }
+}
+
+
+/******************************************************************************
+ * miscellaneous CCM2200 serial driver hook code
+ *****************************************************************************/
+
+int ccm2200_board_serial_ioctl(struct uart_port *port,
+                               unsigned int cmd,
+                               unsigned long arg)
+{
+        register struct ccm2200_board_serial *se = port->ccm2200_serial;
+/*         printk("ccm2200_board_serial_ioctl: cmd: %d\n", cmd); */
+
+        switch (cmd) {
+        case CCM2200_SERIAL_GET_CONF: {
+                struct ccm2200_serial_config new_conf;
+                memcpy(&new_conf, &se->conf, sizeof(se->conf));
+                new_conf.turn_on_delay
+                        = jiffies_to_msecs(new_conf.turn_on_delay);
+                new_conf.turn_off_delay
+                        = jiffies_to_msecs(new_conf.turn_off_delay);
+
+                if (copy_to_user((struct ccm2200_serial_config *)arg,
+                                 &new_conf, sizeof(new_conf)))
+                        return -EFAULT;
+                break;
+        }
+
+        case CCM2200_SERIAL_SET_CONF: {
+                struct ccm2200_serial_config new_conf;
+                int result;
+
+                if (copy_from_user(&new_conf,
+                                   (struct ccm2200_serial_config *)arg,
+                                   sizeof(new_conf)))
+                        return -EFAULT;
+
+                result = ccm2200_board_serial_chg_conf(port, &new_conf);
+                if (result != 0)
+                        return result;
+
+                break;
+        }
+        case CCM2200_SERIAL_GET_TX_LED:
+                if (copy_to_user((struct ccm2200_serial_led *)arg,
+                                 &se->txLed.led, sizeof(se->txLed.led)))
+                        return -EFAULT;
+                break;
+
+        case CCM2200_SERIAL_SET_TX_LED:
+                return ccm2200_board_serial_ioctl_set_led(&se->txLed, arg);
+
+        case CCM2200_SERIAL_GET_RX_LED:
+                if (copy_to_user((struct ccm2200_serial_led *)arg,
+                                 &se->rxLed.led, sizeof(se->rxLed.led)))
+                        return -EFAULT;
+                break;
+
+        case CCM2200_SERIAL_SET_RX_LED:
+                return ccm2200_board_serial_ioctl_set_led(&se->rxLed, arg);
+
+        default:
+                return -ENOIOCTLCMD;
+        }
+        return 0;
+}
+
+
+void ccm2200_board_serial_init(struct uart_port *port,
+                               struct ccm2200_board_serial *se)
+{
+        if (se->state != CCM2200_BS_RECEIVE) {
+                memset(se, 0, sizeof(*se));
+                se->conf.mode = CCM2200_SERIAL_MODE_NORMAL;
+                se->conf.turn_on_delay = 0;
+                se->conf.turn_off_delay = 0;
+                ccm2200_board_serial_led_init(&se->rxLed);
+                ccm2200_board_serial_led_init(&se->txLed);
+                port->ccm2200_serial = se;
+
+                /* alloc and hang in subclassed uart_ops structure */
+                memcpy(&se->ccm2200_ops, port->ops,
+                       sizeof(se->ccm2200_ops));
+
+                se->ccm2200_ops.start_tx = ccm2200_board_serial_start_tx;
+                se->ccm2200_ops.stop_tx = ccm2200_board_serial_stop_tx;
+                se->ccm2200_ops.set_mctrl = ccm2200_board_serial_set_mctrl;
+                se->ccm2200_ops.set_termios = ccm2200_board_serial_set_termios;
+                se->ccm2200_ops.startup = ccm2200_board_serial_startup;
+
+                se->orig_ops = port->ops;
+/*                 printk("----gc 2 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx\n"); */
+                port->ops = &se->ccm2200_ops;
+                init_timer(&se->turn_on_off_timer);
+                se->turn_on_off_timer.function = ccm2200_board_serial_turn_on_off_timer_handler;
+                se->turn_on_off_timer.data = (unsigned long) port;
+
+                se->state = CCM2200_BS_RECEIVE;
+        }
+}
+
+
+void ccm2200_board_serial_remove(struct uart_port *port)
+{
+        register struct ccm2200_board_serial *se = port->ccm2200_serial;
+        if (se->state != CCM2200_BS_NOT_INITIALIZED) {
+
+                del_timer_sync(&se->rxLed.led_timer);
+                del_timer_sync(&se->txLed.led_timer);
+                se->state = CCM2200_BS_NOT_INITIALIZED;
+                port->ops = se->orig_ops;
+        }
+}
+
+
+static int __init ccm2200_serial_init(void)
+{
+	/*
+         * spin_lock_init(&tx_ports_lock);
+         * tx_ports_size = 0;
+         */
+
+        /*
+         * init_timer(&tx_timer);
+	 * tx_timer.function = ccm2200_board_serial_tx_timer_handler;
+	 * tx_timer.data = (unsigned long) 0;
+         * tx_timer.expires = jiffies + 1;
+         */
+
+        printk("CCM2200 board specific serial handling enabled\n");
+
+        return 0;
+}
+
+static void __exit ccm2200_serial_exit(void)
+{
+}
+
+
+module_init(ccm2200_serial_init);
+module_exit(ccm2200_serial_exit);
+
+MODULE_AUTHOR("Guido Classen");
+MODULE_DESCRIPTION("CCM2200 serial LED and piggyback handling ");
+MODULE_LICENSE("GPL");
+
+/*
+ *Local Variables:
+ * mode: c
+ * c-file-style: "linux"
+ * End:
+ */
diff -Nrub '--exclude=*~' linux-orig/arch/arm/mach-at91/Kconfig linux-2.6.21-ccm2200/arch/arm/mach-at91/Kconfig
--- linux-orig/arch/arm/mach-at91/Kconfig	2016-03-22 14:41:04.000000000 +0100
+++ linux-2.6.21-ccm2200/arch/arm/mach-at91/Kconfig	2015-06-18 10:41:42.000000000 +0200
@@ -96,6 +96,12 @@
 	help
 	  Select this if you are using Promwad's Chub board.
 
+config MACH_CCM2200
+	bool "SWARCO Traffic Systems CCM2200 board"
+	depends on ARCH_AT91RM9200
+	help
+	  Select this if you are using the SWARCO Traffic Systems GmbH CCM2200 board
+
 endif
 
 # ----------------------------------------------------------
@@ -228,6 +234,7 @@
 	  Select this if you wish to put the CPU into slow clock mode
 	  while in the "Suspend to RAM" state, to save more power.
 
+
 endmenu
 
 endif
diff -Nrub '--exclude=*~' linux-orig/arch/arm/mach-at91/Makefile linux-2.6.21-ccm2200/arch/arm/mach-at91/Makefile
--- linux-orig/arch/arm/mach-at91/Makefile	2016-03-22 14:41:04.000000000 +0100
+++ linux-2.6.21-ccm2200/arch/arm/mach-at91/Makefile	2015-06-18 10:41:42.000000000 +0200
@@ -56,6 +56,7 @@
 # VGA support
 obj-$(CONFIG_FB_S1D13XXX)	+= ics1523.o
 
+obj-$(CONFIG_MACH_CCM2200)      += ccm2200/
 
 ifeq ($(CONFIG_PM_DEBUG),y)
 CFLAGS_pm.o += -DDEBUG
diff -Nrub '--exclude=*~' linux-orig/build-ccm2200.sh linux-2.6.21-ccm2200/build-ccm2200.sh
--- linux-orig/build-ccm2200.sh	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-ccm2200/build-ccm2200.sh	2015-06-18 10:37:36.000000000 +0200
@@ -0,0 +1,44 @@
+KERNEL_DIR=.
+INSTALL_MOD_PATH=$PWD/../../buildroot/swarco_ch_conf
+MOD_DIRECTORY=2.6.21.7-weiss-ccm2200
+OUTPUT_DIR=$PWD/../output-${PWD##*linux-}
+IMAGE_DIR=../../tftp_root/
+
+
+test -d $OUTPUT_DIR || mkdir -p $OUTPUT_DIR
+test -d $INSTALL_MOD_PATH || mkdir -p $INSTALL_MOD_PATH
+
+if [ -f /usr/bin/kmod ]; then
+# Fedora 17 comes with depmod from kmod 7 package instead of modules_init_tools, which needs this files:
+
+    test -d $INSTALL_MOD_PATH/lib/modules/$MOD_DIRECTORY || mkdir -p $INSTALL_MOD_PATH/lib/modules/$MOD_DIRECTORY
+
+    touch $INSTALL_MOD_PATH/lib/modules/$MOD_DIRECTORY/modules.order
+    touch $INSTALL_MOD_PATH/lib/modules/$MOD_DIRECTORY/modules.builtin
+fi
+
+CPU=arm
+TOOLCHAIN=$PWD/../../buildroot/buildroot-2.0/build_${CPU}/staging_dir/
+PATH=$PATH:$TOOLCHAIN/usr/bin
+export PATH
+
+# add path for u-boot mkimage tool
+PATH=$PATH:$PWD/../../u-boot/u-boot-v2010.09-ccm2200/tools
+export PATH
+
+if [ -z "$1" ]; then
+    set uImage modules modules_install
+fi
+
+
+# KBUILD_VERBOSE=1
+make -C "$KERNEL_DIR" ARCH=arm CROSS_COMPILE="arm-linux-"       \
+                      INSTALL_MOD_PATH=$INSTALL_MOD_PATH        \
+                      O=$OUTPUT_DIR $@ || exit $?
+
+cp $OUTPUT_DIR/arch/arm/boot/uImage $IMAGE_DIR/uImage-ccm2200dev.bin
+
+# Local Variables:
+# mode: shell-script
+# compile-command: "./build-ccm2200.sh"
+# End:
diff -Nrub '--exclude=*~' linux-orig/drivers/char/ccm2200_gpio.c linux-2.6.21-ccm2200/drivers/char/ccm2200_gpio.c
--- linux-orig/drivers/char/ccm2200_gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-ccm2200/drivers/char/ccm2200_gpio.c	2016-03-22 11:34:38.000000000 +0100
@@ -0,0 +1,333 @@
+/*
+ * linux/drivers/char/ccm2200_gpio.c
+ *
+ * Copyright (C) 2006 by Weiss-Electronic GmbH.
+ * Copyright (C) 2010 by SWARCO Traffic Systems GmbH.
+ * All rights reserved.
+ *
+ * @author:     Guido Classen <guido.classen@swarco.de>
+ * @descr:      Userspace access to CCM2200 digital in-/output lines
+ *              and indicator LEDs
+ * @todo:       sophisticated, interrupt driven IO support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  @par Modification History:
+ *     2006-05-04 gc: initial version (partly derived from ite_gpio.c
+ *                    written by Hai-Pao Fan <haipao@mvista.com>)
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/delay.h>
+
+#include <linux/ccm2200_gpio.h>
+
+#include <asm/io.h>       		/* ioremap */
+#include <asm/uaccess.h>		/* copy_to_user */
+#include <asm/arch/hardware.h>
+#include <asm/arch/board.h>
+#include <asm/arch/at91-util.h>
+#include <asm/arch/board-ccm2200.h>
+#include <asm/arch/at91_pio.h>
+#include <asm/arch/at91rm9200_mc.h>
+#include <asm/arch/at91_pmc.h>
+
+
+//#define debug(format, ...) printk(format, ## __VA_ARGS__)
+#define debug(format, ...) 
+
+#define CCM2200_PIOB_IN0_7_MASK         0x00000ff0
+#define CCM2200_PIOB_IN0_7_SHIFT        4
+
+#define CCM2200_PIOD_IN8_9_MASK         (1<<23 | 1<<24)
+#define CCM2200_PIOD_IN8_9_SHIFT        (23-8)
+
+#define CCM2200_PIOD_IN10_11_MASK       (1<<26 | 1<<27)
+#define CCM2200_PIOD_IN10_11_SHIFT      (26-10)
+
+#define CCM2200_PIOD_LED_MASK           0x0000ffff
+#define CCM2200_PIOD_LED_SHIFT          0
+
+
+#define CCM2200_BUS_OUT0_7_MASK         0x000000ff
+#define CCM2200_PIOD_OUT8_11_MASK       0x000f0000
+#define CCM2200_PIOD_OUT8_11_SHIFT      (16-8)
+
+
+/* SCONF0: PIOA27 */
+/* SCONF1: PIOA28 */
+#define CCM2200_PIOA_SCONF0_1_MASK      (1<<27 | 1<<28)
+#define CCM2200_PIOA_SCONF0_1_SHIFT     27
+
+/* preliminary for testing */
+/* SCONF2: PIOC5 */
+#define CCM2200_PIOC_SCONF2_MASK        (1<<5)
+#define CCM2200_PIOC_SCONF2_SHIFT       (5-2)
+
+/* preliminary for testing */
+/* SCONF3: PB28 */
+#define CCM2200_PIOB_SCONF3_MASK        (1<<28)
+#define CCM2200_PIOB_SCONF3_SHIFT       (28-3)
+
+
+static volatile u8 *ccm2200_digital_out_virt = NULL;
+static u32 current_output = 0xf00;
+static u32 current_leds = 0x000;
+
+
+__u32 ccm2200_get_digital_input(void)
+{
+        
+        return ( (at91_sys_read(AT91_PIOB + PIO_PDSR)&CCM2200_PIOB_IN0_7_MASK) 
+                 >> CCM2200_PIOB_IN0_7_SHIFT )
+                | ( (at91_sys_read(AT91_PIOD + PIO_PDSR) & CCM2200_PIOD_IN8_9_MASK) 
+                   >> CCM2200_PIOD_IN8_9_SHIFT )
+                | ( (at91_sys_read(AT91_PIOD + PIO_PDSR) & CCM2200_PIOD_IN10_11_MASK) 
+                   >> CCM2200_PIOD_IN10_11_SHIFT );
+}
+
+__u32 ccm2200_get_sconf_input(void)
+{
+        return ( (at91_sys_read(AT91_PIOA + PIO_PDSR) & CCM2200_PIOA_SCONF0_1_MASK) 
+                 >> CCM2200_PIOA_SCONF0_1_SHIFT )
+                | ( (at91_sys_read(AT91_PIOC + PIO_PDSR) & CCM2200_PIOC_SCONF2_MASK) 
+                   >> CCM2200_PIOC_SCONF2_SHIFT )
+                | ( (at91_sys_read(AT91_PIOB + PIO_PDSR) & CCM2200_PIOB_SCONF3_MASK) 
+                   >> CCM2200_PIOB_SCONF3_SHIFT );
+}
+
+void ccm2200_set_digital_output(register __u32 data, register __u32 mask)
+{
+        current_output = (current_output & ~mask) | (data & mask);
+
+        /* write lower 8 bits over external bus in latch */
+        *ccm2200_digital_out_virt = current_output & CCM2200_BUS_OUT0_7_MASK;
+        /* write upper bit 8...11 to PD16...19 over AT91RM9200 GPIO */
+        {
+                register __u32 value = 
+                        current_output << CCM2200_PIOD_OUT8_11_SHIFT;
+                at91_sys_write(AT91_PIOD + PIO_SODR, value & CCM2200_PIOD_OUT8_11_MASK);
+                at91_sys_write(AT91_PIOD + PIO_CODR, ~value & CCM2200_PIOD_OUT8_11_MASK);
+        }
+}
+
+void ccm2200_set_frontpanel_leds(register __u32 data, register __u32 mask)
+{
+        current_leds = (current_leds & ~mask) | (data & mask);
+        /* invert LED port here! */
+        at91_sys_write(AT91_PIOD + PIO_SODR, ~current_leds & CCM2200_PIOD_LED_MASK);
+        at91_sys_write(AT91_PIOD + PIO_CODR, current_leds  & CCM2200_PIOD_LED_MASK);
+}
+
+
+
+static inline int ccm2200_gpio_out(__u32 device, __u32 mask, __u32 data)
+{
+        switch (device) {
+        case CCM2200_GPIO_OUTPUT:
+                ccm2200_set_digital_output(data, mask);
+                break;
+
+        case CCM2200_GPIO_LED:
+                ccm2200_set_frontpanel_leds(data, mask);
+                break;
+        default:
+                return -EIO;
+        }
+        return 0;
+}
+
+
+static inline int ccm2200_gpio_in(__u32 device, __u32 mask, __u32 *data)
+{
+        switch (device) {
+        case CCM2200_GPIO_INPUT:
+                *data = ccm2200_get_digital_input() & mask;
+                break;
+        case CCM2200_GPIO_SCONF:
+                *data = ccm2200_get_sconf_input() & mask;
+                break;
+        case CCM2200_GPIO_OUTPUT:
+                *data = current_output & mask;
+                break;
+        case CCM2200_GPIO_LED:
+                *data = current_leds & mask;
+                break;
+        default:
+                return -EIO;
+        }
+        return 0;
+}
+
+static int ccm2200_gpio_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+
+static int ccm2200_gpio_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+
+static int ccm2200_gpio_ioctl(struct inode *inode, struct file *file,
+	unsigned int cmd, unsigned long arg)
+{
+	static struct ccm2200_gpio_ioctl_data ioctl_data;
+
+	if (copy_from_user(&ioctl_data, (struct ccm2200_gpio_ioctl_data *)arg,
+                           sizeof(ioctl_data)))
+		return -EFAULT;
+
+	switch(cmd) {
+        case CCM2200_GPIO_IN:
+                if (ccm2200_gpio_in(ioctl_data.device, ioctl_data.mask,
+                		   &ioctl_data.data))
+                	return -EFAULT;
+                if (copy_to_user((struct ccm2200_gpio_ioctl_data *)arg,
+                                 &ioctl_data, sizeof(ioctl_data)))
+                        return -EFAULT;
+                break;
+
+        case CCM2200_GPIO_OUT:
+                debug("CCM2200_GPIO_OUT: %d, 0x%08x, 0x%08x\n",
+                      ioctl_data.device,
+                      ioctl_data.mask, ioctl_data.data);
+                return ccm2200_gpio_out(ioctl_data.device,
+                                        ioctl_data.mask, ioctl_data.data);
+                break;
+
+        default:
+                return -ENOIOCTLCMD;
+                
+	}
+
+	return 0;
+}
+
+static struct file_operations ccm2200_gpio_fops = {
+	.owner		= THIS_MODULE,
+	.ioctl		= ccm2200_gpio_ioctl,
+	.open		= ccm2200_gpio_open,
+	.release	= ccm2200_gpio_release,
+};
+
+static struct miscdevice ccm2200_gpio_miscdev = {
+	MISC_DYNAMIC_MINOR,
+	"ccm2200_gpio",
+	&ccm2200_gpio_fops
+};
+
+int __init ccm2200_gpio_init(void)
+{
+        /* prepare digital outputs over bus and static memory controller */
+
+
+        /*
+         * Setup static memory controller chip select for digital output
+         *
+         */
+        static const struct at91_smc_cs_info __initdata dig_out_cs_config = {
+                .chip_select          = CCM2200_DIG_OUT_CS,
+                .wait_states          = 2, /* enough wait states... */
+                .data_float_time      = 0,
+                .byte_access_type     = AT91_BAT_8_BIT,
+                .data_bus_width       = AT91_DATA_BUS_WIDTH_8,
+                .data_read_protocol   = AT91_DRP_STANDARD,
+                .address_to_cs_setup  = AT91_ACSS_1_CYCLE,
+                .rw_setup             = 2, /* 2 cycle rw_setup! */
+                .rw_hold              = 2  /* 2 cycle rw_hold! */
+        };
+
+        if ( at91_config_smc_cs( &dig_out_cs_config ) != 0 ) {
+	    printk( KERN_ERR 
+                    "Unable to configure digital out chip select signal\n" );
+            return -EIO;
+	}
+
+	ccm2200_digital_out_virt = ioremap_nocache(CCM2200_DIG_OUT_PHYS, 
+                                                   CCM2200_DIG_OUT_SIZE );
+	if (!ccm2200_digital_out_virt) {
+		printk("Failed to ioremap CCM2200 digital output\n");
+		return -EIO;
+	}
+
+
+        /* prepare LED outputs and FG6 outputs on PIOD */
+        {
+                static const struct at91_pio_pins ccm2200_out_pio_d = { 
+                        AT91_PIO_BASE(AT91_PIOD), 
+                        CCM2200_PIOD_LED_MASK | CCM2200_PIOD_OUT8_11_MASK 
+                };
+                /* reset extern latch pin */
+                static const struct at91_pio_pins ccm2200_n_ext_reset = 
+                        { AT91_PIO_BASE(AT91_PIOB), 1<<3 }; 
+
+                at91_pio_enable_open_drain_pins(&ccm2200_out_pio_d);  
+		/* 2016-03-22 gc: set digital outs register to "1" => tri-state,
+		 *                so we keep the initial state set after
+		 *                CPU reset
+		 */
+		at91_pio_assign_pins(&ccm2200_out_pio_d, 
+				     CCM2200_PIOD_OUT8_11_MASK);
+                at91_pio_config_output_pins(&ccm2200_out_pio_d);
+                /* assert reset signal to external latch */
+                at91_pio_clear_all_pins(&ccm2200_n_ext_reset);
+                at91_pio_config_output_pins(&ccm2200_n_ext_reset);
+                udelay(10);
+                at91_pio_set_all_pins(&ccm2200_n_ext_reset);
+        }
+
+	if (misc_register(&ccm2200_gpio_miscdev)) {
+                iounmap((void *) ccm2200_digital_out_virt);
+		return -ENODEV;
+        }
+
+	printk("CCM2200 GPIO driver initialized\n");
+
+	return 0;
+}	
+
+static void __exit ccm2200_gpio_exit(void)
+{
+	misc_deregister(&ccm2200_gpio_miscdev);
+        if (ccm2200_digital_out_virt) {
+                iounmap((void *) ccm2200_digital_out_virt);
+                ccm2200_digital_out_virt = NULL;
+        }
+}
+
+module_init(ccm2200_gpio_init);
+module_exit(ccm2200_gpio_exit);
+
+MODULE_AUTHOR("Guido Classen");
+MODULE_DESCRIPTION("CCM2200 GPIO driver");
+MODULE_LICENSE("GPL");
+
+/*
+ *Local Variables:
+ * mode: c
+ * c-file-style: "linux"
+ * End:
+ */
diff -Nrub '--exclude=*~' linux-orig/drivers/char/Kconfig linux-2.6.21-ccm2200/drivers/char/Kconfig
--- linux-orig/drivers/char/Kconfig	2016-03-22 14:41:04.000000000 +0100
+++ linux-2.6.21-ccm2200/drivers/char/Kconfig	2015-06-18 10:41:42.000000000 +0200
@@ -1087,5 +1087,21 @@
 	  The SPI driver gives user mode access to this serial
 	  bus on the AT91RM9200 processor.
 
+config CCM2200_I2C_EEPROM
+	tristate "I2C Eeprom char device (/dev/i2c_eeprom) for CCM2200 board"
+	depends on MACH_CCM2200 && I2C_AT91
+  	default y
+  	help
+  	  The I2C EEPROM driver gives user mode access to the built-in
+          serial EEPROM
+config CCM2200_I2C_EEPROM_IP
+	bool "Use I2C eeprom IP settings for autoconfiguration for CCM2200 board"
+	depends on CCM2200_I2C_EEPROM
+	default y
+	help
+	  Say yes if you want to use the IP addresses stored within the I2C
+	  EEPROM on the CCM2200. This will autoconfigure the module IP address,
+	  network mask, gateway, etc. 
+ 
 endmenu
 
diff -Nrub '--exclude=*~' linux-orig/drivers/char/Makefile linux-2.6.21-ccm2200/drivers/char/Makefile
--- linux-orig/drivers/char/Makefile	2016-03-22 14:41:04.000000000 +0100
+++ linux-2.6.21-ccm2200/drivers/char/Makefile	2015-06-18 10:41:42.000000000 +0200
@@ -87,6 +87,7 @@
 obj-$(CONFIG_NWBUTTON)		+= nwbutton.o
 obj-$(CONFIG_NWFLASH)		+= nwflash.o
 obj-$(CONFIG_SCx200_GPIO)	+= scx200_gpio.o
+obj-$(CONFIG_MACH_CCM2200)      += ccm2200_gpio.o
 obj-$(CONFIG_PC8736x_GPIO)	+= pc8736x_gpio.o
 obj-$(CONFIG_NSC_GPIO)		+= nsc_gpio.o
 obj-$(CONFIG_CS5535_GPIO)	+= cs5535_gpio.o
diff -Nrub '--exclude=*~' linux-orig/drivers/char/watchdog/ccm2200_watchdog.c linux-2.6.21-ccm2200/drivers/char/watchdog/ccm2200_watchdog.c
--- linux-orig/drivers/char/watchdog/ccm2200_watchdog.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-ccm2200/drivers/char/watchdog/ccm2200_watchdog.c	2015-06-18 10:41:42.000000000 +0200
@@ -0,0 +1,226 @@
+/*
+ * drivers/char/watchdog/ccm2200_watchdog.c
+ *
+ * Copyright (C) 2007 by Weiss-Electronic GmbH.
+ * Copyright (C) 2010 by SWARCO Traffic Systems GmbH.
+ * All rights reserved.
+ *
+ * @author:     Guido Classen <guido.classen@swarco.de>
+ * @descr:      Trigger CCM2200 board specific watchdog chip MAX6751.
+ *              This watchdog is started direct after rest and has a timeout 
+ *              period of 64 seconds. The application can reduce the watchdog
+ *              timeout period to 0.5 second.
+ *
+ *              The AT91RM9200 internal watchdog can be used together
+ *              with this driver to get shorter watchdog periods using
+ *              the at91_wdt.c driver.
+ * @references:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  @par Modification History:
+ *     2007-02-01 gc: initial version
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/watchdog.h>
+#include <asm/bitops.h> 
+#include <asm/uaccess.h>
+#include <linux/init.h>
+#include <asm/arch/at91-util.h>
+#include <asm/arch/board-ccm2200.h>
+#include <linux/ccm2200_gpio.h>
+
+#define WDT_DEFAULT_TIME 64	/* 64 seconds */
+
+static int ccm2200_wdt_time = WDT_DEFAULT_TIME;
+static unsigned long ccm2200_wdt_busy;
+static u32 ccm2200_watchdog_led = 0;
+
+/*************************************************************************
+ *  hw_watchdog_reset
+ *
+ *	This routine is called to reset (keep alive) the watchdog timer
+ *
+ ************************************************************************/
+
+static struct at91_pio_pins watchdog_trigger = {
+        AT91_PIO_BASE(AT91_PIOA), 1<<21
+};
+
+static struct at91_pio_pins watchdog_speed = {
+        AT91_PIO_BASE(AT91_PIOA), 1<<29
+};
+
+void hw_watchdog_reset(void)
+{
+
+        static unsigned long last_reset = 0;
+        static unsigned led = 0;
+       
+        /* do reset only once all 500msec */
+        if ((unsigned long) (jiffies - last_reset) 
+            > (unsigned long) (HZ / 2)) {
+                
+                /* assert reset signal to external watchdog */
+                at91_pio_clear_all_pins(&watchdog_trigger);
+                //udelay(1);
+                at91_pio_set_all_pins(&watchdog_trigger);
+                /* blink with LED to indicate the running watchdog */
+                led ^= ccm2200_watchdog_led;
+                ccm2200_set_frontpanel_leds(led, ccm2200_watchdog_led);
+                last_reset = jiffies;
+        }
+}
+
+
+/* ......................................................................... */
+
+/*
+ * Watchdog device is opened, and watchdog starts running.
+ */
+static int ccm2200_wdt_open(struct inode *inode, struct file *file)
+{
+	if (test_and_set_bit(1, &ccm2200_wdt_busy))
+		return -EBUSY;
+
+	return 0;
+}
+
+/*
+ * Close the watchdog device.
+ * If CONFIG_WATCHDOG_NOWAYOUT is NOT defined then the watchdog is also
+ *  disabled.
+ */
+static int ccm2200_wdt_close(struct inode *inode, struct file *file)
+{
+	ccm2200_wdt_busy = 0;
+	return 0;
+}
+
+/*
+ * Handle commands from user-space.
+ */
+static int ccm2200_wdt_ioctl(struct inode *inode, struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	unsigned int new_value;
+	static struct watchdog_info info = {
+		identity: "CCM2200 MAX6751 watchdog",
+		options:  WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING,
+	};
+
+	switch(cmd) {
+	case WDIOC_KEEPALIVE:
+		hw_watchdog_reset();
+		return 0;
+
+	case WDIOC_GETSUPPORT:
+		return copy_to_user((struct watchdog_info *)arg, 
+				    &info, sizeof(info));
+
+	case WDIOC_SETTIMEOUT:
+		if (get_user(new_value, (int *)arg))
+			return -EFAULT;
+		if ((new_value <= 0) || (new_value > WDT_DEFAULT_TIME))
+			return -EINVAL;
+
+		if (new_value <= 1) {
+			at91_pio_clear_all_pins(&watchdog_speed);
+			ccm2200_wdt_time = 0;
+		} else {
+			at91_pio_set_all_pins(&watchdog_speed);
+			ccm2200_wdt_time = WDT_DEFAULT_TIME;
+		}
+		/* Return current value */
+		return put_user(ccm2200_wdt_time, (int *)arg);
+
+	case WDIOC_GETTIMEOUT:
+		return put_user(ccm2200_wdt_time, (int *)arg);
+
+	case WDIOC_GETSTATUS:
+	case WDIOC_GETBOOTSTATUS:
+		return put_user(0, (int *)arg);
+
+        case CCM2200_WDIOC_SETLED:
+		if (get_user(new_value, (int *)arg))
+			return -EFAULT;
+		ccm2200_watchdog_led = new_value; 
+                return 0;
+		/* case WDIOC_SETOPTIONS: */
+                        
+	default:
+		return -ENOIOCTLCMD;
+	}
+}
+
+/*
+ * Pat the watchdog whenever device is written to.
+ */
+static ssize_t ccm2200_wdt_write(struct file *file, const char *data, size_t len, loff_t *ppos)
+{
+        hw_watchdog_reset();
+	return len;
+}
+
+/* ......................................................................... */
+
+static struct file_operations ccm2200_wdt_fops =
+{
+	.owner		= THIS_MODULE,
+	.ioctl		= ccm2200_wdt_ioctl,
+	.open		= ccm2200_wdt_open,
+	.release	= ccm2200_wdt_close,
+	.write		= ccm2200_wdt_write,
+};
+
+static struct miscdevice ccm2200_wdt_miscdev =
+{
+	.minor		= WATCHDOG_MINOR+1,
+	.name		= "ccm2200_watchdog",
+	.fops		= &ccm2200_wdt_fops,
+};
+
+static int __init ccm2200_wdt_init(void)
+{
+	int res;
+
+        at91_pio_set_all_pins(&watchdog_trigger);
+        at91_pio_config_output_pins(&watchdog_trigger);
+        at91_pio_set_all_pins(&watchdog_speed);
+        at91_pio_config_output_pins(&watchdog_speed);
+
+	res = misc_register(&ccm2200_wdt_miscdev);
+	if (res)
+		return res;
+
+	printk("CCM2200 Watchdog Timer enabled (%d seconds)\n", 
+               WDT_DEFAULT_TIME);
+	return 0;
+}
+
+static void __exit ccm2200_wdt_exit(void)
+{
+	misc_deregister(&ccm2200_wdt_miscdev);
+}
+
+module_init(ccm2200_wdt_init);
+module_exit(ccm2200_wdt_exit);
+
+MODULE_LICENSE("GPL")
+MODULE_AUTHOR("Guido Classen")
+MODULE_DESCRIPTION("Watchdog driver for CCM2200 board (MAX6751 Chip)")
diff -Nrub '--exclude=*~' linux-orig/drivers/char/watchdog/Kconfig linux-2.6.21-ccm2200/drivers/char/watchdog/Kconfig
--- linux-orig/drivers/char/watchdog/Kconfig	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21-ccm2200/drivers/char/watchdog/Kconfig	2015-06-18 10:41:42.000000000 +0200
@@ -183,6 +183,14 @@
 
 	  Say N if you are unsure.
 
+config CCM2200_WATCHDOG
+	tristate "CCM2200 board watchdog support"
+	depends on WATCHDOG && MACH_CCM2200
+	help
+	  Watchdog driver for CCM2200 board (MAX6751 Chip). This will
+          reboot your system when the timeout is reached.
+	  
+
 # X86 (i386 + ia64 + x86_64) Architecture
 
 config ACQUIRE_WDT
diff -Nrub '--exclude=*~' linux-orig/drivers/char/watchdog/Makefile linux-2.6.21-ccm2200/drivers/char/watchdog/Makefile
--- linux-orig/drivers/char/watchdog/Makefile	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21-ccm2200/drivers/char/watchdog/Makefile	2015-06-18 10:41:42.000000000 +0200
@@ -34,6 +34,7 @@
 obj-$(CONFIG_MPCORE_WATCHDOG) += mpcore_wdt.o
 obj-$(CONFIG_EP93XX_WATCHDOG) += ep93xx_wdt.o
 obj-$(CONFIG_PNX4008_WATCHDOG) += pnx4008_wdt.o
+obj-$(CONFIG_CCM2200_WATCHDOG) += ccm2200_watchdog.o
 
 # X86 (i386 + ia64 + x86_64) Architecture
 obj-$(CONFIG_ACQUIRE_WDT) += acquirewdt.o
diff -Nrub '--exclude=*~' linux-orig/drivers/leds/Kconfig linux-2.6.21-ccm2200/drivers/leds/Kconfig
--- linux-orig/drivers/leds/Kconfig	2016-03-22 14:41:04.000000000 +0100
+++ linux-2.6.21-ccm2200/drivers/leds/Kconfig	2015-06-18 10:41:42.000000000 +0200
@@ -83,6 +83,12 @@
 	  This option enables support for LEDs connected to GPIO lines
 	  on AT91-based boards.
 
+config LEDS_CCM2200
+	tristate "LED support using CCM2200 LED functions"
+	depends on LEDS_CLASS && ARCH_AT91 && MACH_CCM2200 && !LEDS
+	help
+	  This option enables support for CCM2200 board frontpanel LEDs.
+
 config LEDS_WRAP
 	tristate "LED Support for the WRAP series LEDs"
 	depends on LEDS_CLASS && SCx200_GPIO
diff -Nrub '--exclude=*~' linux-orig/drivers/leds/leds-ccm2200.c linux-2.6.21-ccm2200/drivers/leds/leds-ccm2200.c
--- linux-orig/drivers/leds/leds-ccm2200.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-ccm2200/drivers/leds/leds-ccm2200.c	2015-06-18 10:41:42.000000000 +0200
@@ -0,0 +1,156 @@
+/*
+ * linux/drivers/leds/leds-ccm2200.c
+ *
+ * Copyright (C) 2007 by Weiss-Electronic GmbH.
+ * Copyright (C) 2010 by SWARCO Traffic Systems GmbH.
+ * All rights reserved.
+ *
+ * @author:     Guido Classen <guido.classen@swarco.de>
+ * @descr:      Userspace access to CCM2200 frontpanel indicator LEDs
+ *              using Linux kernel LED framework
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  @par Modification History:
+ *     2007-09-10 gc: initial version (derived from leds-at91
+ *                    written by David Brownell)
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+
+#include <asm/arch/board.h>
+#include <asm/arch/gpio.h>
+
+struct ccm2200_led {
+	struct led_classdev	cdev;
+	unsigned		mask;
+	char			name[8]; // "ledxx"
+};
+
+
+#define CCM2200_NUM_LEDS	16
+static struct ccm2200_led ccm2200_leds[CCM2200_NUM_LEDS];
+
+
+
+/*
+ * Change the state of the LED.
+ */
+static void ccm2200_led_set(struct led_classdev *cdev, enum led_brightness value)
+{
+	struct ccm2200_led	*led = container_of(cdev, struct ccm2200_led, cdev);
+
+
+	ccm2200_set_frontpanel_leds(
+		(value == LED_OFF) ? 0 : led->mask, led->mask);
+}
+
+static int __devexit ccm2200_led_remove(struct platform_device *pdev)
+{
+	struct ccm2200_led		*led;
+
+	for (led = ccm2200_leds; led < ccm2200_leds+CCM2200_NUM_LEDS; ++led) {
+		
+		led_classdev_unregister(&led->cdev);
+	}
+	return 0;
+}
+
+static int __init ccm2200_led_probe(struct platform_device *pdev)
+{
+	int			status = 0;
+	int			i;
+	unsigned		nr_leds;
+	struct ccm2200_led	*led = ccm2200_leds;
+
+	for (i=0; i < CCM2200_NUM_LEDS; ++i) {
+		memset(led, 0, sizeof(*led));
+		led->mask	= 1 << i;
+		snprintf(led->name, sizeof(led->name), "led%d", i);
+		led->cdev.name = led->name;
+		led->cdev.brightness_set = ccm2200_led_set,
+		led->cdev.default_trigger = NULL;
+
+		status = led_classdev_register(&pdev->dev, &led->cdev);
+		if (status < 0) {
+			dev_err(&pdev->dev, "led_classdev_register failed - %d\n", status);
+cleanup:
+			ccm2200_led_remove(pdev);
+			break;
+		}
+		++led;
+	}
+	return status;
+}
+
+#ifdef CONFIG_PM
+static int ccm2200_led_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct ccm2200_led	*led;
+
+	for (led = ccm2200_leds; led < ccm2200_leds+CCM2200_NUM_LEDS; ++led) {
+		
+		led_classdev_suspend(&led->cdev);
+	}
+
+	return 0;
+}
+
+static int ccm2200_led_resume(struct platform_device *dev)
+{
+	struct ccm2200_led	*led;
+
+	for (led = ccm2200_leds; led < ccm2200_leds+CCM2200_NUM_LEDS; ++led) {
+		
+		led_classdev_resume(&led->cdev);
+	}
+
+	return 0;
+}
+#else
+#define	ccm2200_led_suspend	NULL
+#define	ccm2200_led_resume		NULL
+#endif
+
+static struct platform_driver ccm2200_led_driver = {
+	.probe		= ccm2200_led_probe,
+	.remove		= __devexit_p(ccm2200_led_remove),
+	.suspend	= ccm2200_led_suspend,
+	.resume		= ccm2200_led_resume,
+	.driver		= {
+		.name	= "ccm2200_leds",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init ccm2200_led_init(void)
+{
+	return platform_driver_register(&ccm2200_led_driver);
+}
+module_init(ccm2200_led_init);
+
+static void __exit ccm2200_led_exit(void)
+{
+	platform_driver_unregister(&ccm2200_led_driver);
+}
+module_exit(ccm2200_led_exit);
+
+MODULE_DESCRIPTION("CCM2200 LED driver");
+MODULE_AUTHOR("Guido Classen");
+MODULE_LICENSE("GPL");
diff -Nrub '--exclude=*~' linux-orig/drivers/leds/Makefile linux-2.6.21-ccm2200/drivers/leds/Makefile
--- linux-orig/drivers/leds/Makefile	2016-03-22 14:41:04.000000000 +0100
+++ linux-2.6.21-ccm2200/drivers/leds/Makefile	2015-06-18 10:41:42.000000000 +0200
@@ -17,6 +17,7 @@
 obj-$(CONFIG_LEDS_H1940)		+= leds-h1940.o
 obj-$(CONFIG_LEDS_COBALT)		+= leds-cobalt.o
 obj-$(CONFIG_LEDS_AT91)			+= leds-at91.o
+obj-$(CONFIG_LEDS_CCM2200)		+= leds-ccm2200.o
 
 # LED Triggers
 obj-$(CONFIG_LEDS_TRIGGER_TIMER)	+= ledtrig-timer.o
diff -Nrub '--exclude=*~' linux-orig/drivers/mtd/maps/ccm2200-nor.c linux-2.6.21-ccm2200/drivers/mtd/maps/ccm2200-nor.c
--- linux-orig/drivers/mtd/maps/ccm2200-nor.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-ccm2200/drivers/mtd/maps/ccm2200-nor.c	2015-06-18 10:41:42.000000000 +0200
@@ -0,0 +1,192 @@
+/*
+ * linux/drivers/mtd/maps/ccm2200-sram.c
+ *
+ * Copyright (C) 2006 by Weiss-Electronic GmbH.
+ * Copyright (C) 2010 by SWARCO Traffic Systems GmbH.
+ * All rights reserved.
+ *
+ * @author:     Guido Classen <guido.classen@swarco.de>
+ * @descr:      MTD mapping and access for non-volatile SRAM from CCM2200 board
+ *
+ * @references: [1] based on modarm9.c by Markus Pietrek
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  @par Modification History:
+ *     2007-06-04 gc: initial version (based on modarm9.c by Markus Pietrek,
+ *                    FS Forth-Systeme GmbH)
+ */
+
+#include <linux/autoconf.h>
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <linux/ioport.h>	/* request_mem_region */
+
+#define DRIVER_NAME	"CCM2200"
+
+/* 2006-04-24 gc: support for CCM2200 */
+#if defined(CONFIG_MACH_CCM2200)
+
+#include <asm/arch/hardware.h>
+
+#define FLASH_MEM_BASE_P	AT91_CHIPSELECT_0
+#define FLASH_SIZE		0x001000000
+#define	FLASH_BANK_WIDTH	2
+
+/* 2006-04-24 gc: SWARCO Traffic Systems CCM2200 mapping */
+static struct mtd_partition ccm2200_partitions[] = {
+	{
+		.name       = "all-ccm2200",
+		.offset     = 0x00000000,
+	},
+	{
+		.name       = "u-boot",
+		.offset     = 0x00000000,
+		.size       = 0x00040000,	// 4 * 64kB for u-boot and boot.bin 
+	},
+	{
+		.name       = "kernel",		// default kernel image (1.75MB)
+		.offset     = 0x00040000,
+		.size       = 0x1c0000,
+	},
+	{
+		.name       = "dummy",		// dummy partion to get nand at MTD5
+		.offset     = 0x00200000,
+		.size       = 0x00000000,
+	},
+};
+
+#endif /* defined(CONFIG_MACH_CCM2200) */
+
+
+static struct map_info ccm2200_map = 
+{
+	.name      = "ccm2200",
+	.phys 	   = FLASH_MEM_BASE_P, 
+	.size 	   = FLASH_SIZE, 
+	.bankwidth = FLASH_BANK_WIDTH,
+};
+
+static struct mtd_partition* parsed_parts;
+static const char* part_probes[] = { "cmdlinepart", NULL };
+static struct mtd_info* mtd_info;
+static struct resource* mtd_res;
+
+static int __init ccm2200_mtd_init( void )
+{
+	const char* part_type = NULL;
+	int nr_parts = 0;
+	int ret = 0;
+
+	printk( KERN_INFO DRIVER_NAME
+		": Using NOR Flash device: %lu kB @ 0x%x\n",
+		ccm2200_map.size / 1024, (unsigned int)ccm2200_map.phys );
+
+	mtd_res = request_mem_region( ccm2200_map.phys, ccm2200_map.size,
+				      ccm2200_map.name );
+	if( mtd_res == NULL ) {
+		ret = -EBUSY;
+		goto error;
+	}
+
+	ccm2200_map.virt = (void __iomem *) ioremap( ccm2200_map.phys,
+						     ccm2200_map.size );
+	if( !ccm2200_map.virt ) {
+		ret = -ENOMEM;
+		goto error_map;
+	}
+	
+	simple_map_init( &ccm2200_map );
+
+	/* probe if there is really flash */
+
+#ifdef CONFIG_MACH_CCXP
+	mtd_info = NULL;
+#else
+	mtd_info = do_map_probe( "amd_flash", &ccm2200_map );
+#endif
+	if( mtd_info == NULL ) {
+		mtd_info = do_map_probe( "cfi_probe", &ccm2200_map );
+		if( mtd_info == NULL ) {
+			ret = -ENXIO;
+			goto error_probe;
+		}
+	}
+	
+	mtd_info->owner = THIS_MODULE;
+
+	/* setup partitions */
+#ifdef CONFIG_MTD_PARTITIONS
+	nr_parts = parse_mtd_partitions( mtd_info, part_probes,
+					 &parsed_parts, 0 );
+	if( nr_parts > 0 )
+		part_type = "dynamic";
+	else {
+		parsed_parts = ccm2200_partitions;
+		nr_parts = ARRAY_SIZE( ccm2200_partitions );
+		part_type = "static";
+	}
+#endif
+
+	if( nr_parts == 0 ) {
+		printk( KERN_INFO DRIVER_NAME ": no partition info "
+			"available, registering whole flash\n" );
+		add_mtd_device( mtd_info );
+	} else {
+		printk( KERN_INFO DRIVER_NAME ": using %s partition "
+			"definition\n", part_type );
+		add_mtd_partitions( mtd_info, parsed_parts, nr_parts );
+	}
+
+	return 0;
+
+error_probe:
+	iounmap( ccm2200_map.virt );
+
+error_map:
+	release_resource( mtd_res );
+
+error:
+	return ret;
+}
+
+static void __exit ccm2200_mtd_cleanup( void )
+{
+
+	del_mtd_partitions( mtd_info );
+
+	if( parsed_parts )
+		kfree( parsed_parts );
+
+	iounmap( ccm2200_map.virt );
+
+	release_resource( mtd_res );
+
+	parsed_parts = NULL;
+}
+
+module_init( ccm2200_mtd_init );
+module_exit( ccm2200_mtd_cleanup );
+
+MODULE_AUTHOR( "Guido Classen <guido.classen@swarco.de>" );
+MODULE_DESCRIPTION( "CCM2200 NOR flash mapping driver" );
+MODULE_LICENSE( "GPL" );
diff -Nrub '--exclude=*~' linux-orig/drivers/mtd/maps/ccm2200-sram.c linux-2.6.21-ccm2200/drivers/mtd/maps/ccm2200-sram.c
--- linux-orig/drivers/mtd/maps/ccm2200-sram.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-ccm2200/drivers/mtd/maps/ccm2200-sram.c	2015-06-18 10:41:42.000000000 +0200
@@ -0,0 +1,205 @@
+/*
+ * linux/drivers/mtd/maps/ccm2200-sram.c
+ *
+ * Copyright (C) 2006 by Weiss-Electronic GmbH.
+ * Copyright (C) 2010 by SWARCO Traffic Systems GmbH.
+ * All rights reserved.
+ *
+ * @author:     Guido Classen <guido.classen@swarco.de>
+ * @descr:      MTD mapping and access for non-volatile SRAM from CCM2200 board
+ *
+ * @references: [1] based on autcpu12-nvram.c by Thomas Gleixner
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  @par Modification History:
+ *     2006-05-02 gc: initial version (based on autcpu12-nvram.c by Thomas
+ *                    Gleixner)
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+
+#include <asm/io.h>
+#include <asm/sizes.h>
+#include <asm/hardware.h>
+
+#include <asm/arch/at91-util.h>
+#include <asm/arch/board-ccm2200.h>
+
+#include <linux/delay.h>		/* udelay */
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+
+static struct mtd_info *sram_mtd;
+
+struct map_info ccm2200_sram_map = {
+	.name           = "sram-ccm2200",
+	.size           = CCM2200_SRAM_SIZE,
+	.bankwidth      = 4,    /* use 32bit access for more speed! */
+	.phys           = CCM2200_SRAM_PHYS,
+};
+
+//#define TEST_SRAM       1       /* test if SRAM timing is okay */
+
+#ifdef TEST_SRAM
+static void print(const char *str, void *addr)
+{
+  u32 *u32ptr = (u32*) addr;
+  u8 *u8ptr   = (u8*)  addr;
+  u16 *u16ptr = (u16*) addr;
+  printk("%s test read u32: %08x - ", str, *u32ptr);
+  printk("u16: %04x %04x - ", u16ptr[0], u16ptr[1]);
+  printk("u8: %02x %02x %02x %02x\n", 
+         u8ptr[0], u8ptr[1], u8ptr[2], u8ptr[3]);
+}
+
+static void test32(const char *str, void *addr)
+{
+  *(u32*)addr = 0x0badaffe;
+  printk("test32 ");
+  print(str, addr);
+}
+
+static void test16(const char *str, void *addr)
+{
+  u16 *u16ptr = (u16*) addr;
+  u16ptr[0] = 0xaffe;
+  u16ptr[1] = 0x0bad;
+  printk("test16 ");
+  print(str, addr);
+}
+
+
+static void test8(const char *str, void *addr)
+{
+  u8 *u8ptr = (u8*) addr;
+  u8ptr[0] = 0xfe;
+  u8ptr[1] = 0xaf;
+  u8ptr[2] = 0xad;
+  u8ptr[3] = 0x0b;
+  printk("test8  ");
+  print(str, addr);
+}
+#endif
+
+static int __init init_ccm2200_sram (void)
+{
+	int err;
+
+        /*
+         * Setup static memory controller chip select for SRAM
+         *
+         */
+        static const struct at91_smc_cs_info __initdata sram_cs_config = {
+                .chip_select          = CCM2200_SRAM_CS,
+                .wait_states          = 15, /* SRAM needs at least 3 wait states! */
+                .data_float_time      = 2,
+                .byte_access_type     = AT91_BAT_16_BIT,
+                .data_bus_width       = AT91_DATA_BUS_WIDTH_16,
+                .data_read_protocol   = AT91_DRP_EARLY, //AT91_DRP_STANDARD,
+                .address_to_cs_setup  = AT91_ACSS_STANDARD,
+                .rw_setup             = 2, /* SRAM needs 1 cycle rw_setup! */
+                .rw_hold              = 2  /* SRAM needs 1 cycle rw_hold! */
+        };
+
+        if ( at91_config_smc_cs( &sram_cs_config ) != 0 ) {
+	    printk( KERN_ERR 
+                    "Unable to configure SRAM chip select signal\n" );
+            return -EIO;
+	}
+
+	ccm2200_sram_map.virt = ioremap_nocache(CCM2200_SRAM_PHYS, 
+                                                CCM2200_SRAM_SIZE );
+	if (!ccm2200_sram_map.virt) {
+		printk("Failed to ioremap CCM2200 SRAM space\n");
+		err = -EIO;
+		goto out;
+	}
+
+#ifdef TEST_SRAM
+        /* SRAM timing test
+         * test output from correct running SRAM:
+test8  x test read u32: 0badaffe - u16: affe 0bad - u8: fe af ad 0b
+test16 x test read u32: 0badaffe - u16: affe 0bad - u8: fe af ad 0b
+test32 x test read u32: 0badaffe - u16: affe 0bad - u8: fe af ad 0b
+test8  sram std test read u32: 0badaffe - u16: affe 0bad - u8: fe af ad 0b
+test16 sram std test read u32: 0badaffe - u16: affe 0bad - u8: fe af ad 0b
+test32 sram std test read u32: 0badaffe - u16: affe 0bad - u8: fe af ad 0b
+
+         */
+        { 
+          u32 x;
+          test8("x", &x);
+          test16("x", &x);
+          test32("x", &x);
+          test8("sram std", ccm2200_sram_map.virt);
+          test16("sram std", ccm2200_sram_map.virt);
+          test32("sram std", ccm2200_sram_map.virt);
+        }
+#endif
+
+	simple_map_init(&ccm2200_sram_map);
+	sram_mtd = do_map_probe("map_ram", &ccm2200_sram_map);
+	if (!sram_mtd) {
+		printk("CCM22200 SRAM probe failed\n");
+		err = -ENXIO;
+		goto out_ioremap;
+	}
+
+	sram_mtd->owner = THIS_MODULE;
+	sram_mtd->erasesize = 16;
+	
+	if (add_mtd_device(sram_mtd)) {
+		printk("SRAM device addition failed\n");
+		err = -ENOMEM;
+		goto out_probe;
+	}
+
+	printk("SRAM device size %ldKiB registered on CCM2200\n",
+               ccm2200_sram_map.size/SZ_1K);
+		
+	return 0;
+
+out_probe:
+	map_destroy(sram_mtd);
+	sram_mtd = 0;
+
+out_ioremap:
+	iounmap((void *)ccm2200_sram_map.virt);
+out:
+	return err;
+}
+
+static void __exit cleanup_ccm2200_maps(void)
+{
+	if (sram_mtd) {
+		del_mtd_device(sram_mtd);
+		map_destroy(sram_mtd);
+		iounmap((void *)ccm2200_sram_map.virt);
+	}
+}
+
+module_init(init_ccm2200_sram);
+module_exit(cleanup_ccm2200_maps);
+
+MODULE_AUTHOR("Guido Classen");
+MODULE_DESCRIPTION("CCM2200 SRAM map driver");
+MODULE_LICENSE("GPL");
diff -Nrub '--exclude=*~' linux-orig/drivers/mtd/maps/Kconfig linux-2.6.21-ccm2200/drivers/mtd/maps/Kconfig
--- linux-orig/drivers/mtd/maps/Kconfig	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21-ccm2200/drivers/mtd/maps/Kconfig	2015-06-18 10:41:42.000000000 +0200
@@ -605,5 +605,19 @@
 
 	  This selection automatically selects the map_ram driver.
 
+config MTD_CCM2200_NOR
+	tristate "mapping for NOR Flash con CCM2200"
+	depends on MTD_CFI && MACH_CCM2200
+	help
+	  Map driver for the NOR Flash on 
+          SWARCO Traffic Systems CCM2200 board.
+
+config MTD_CCM2200_SRAM
+	tristate "mapping for battery backuped SRAM on CCM2200"
+	depends on MTD_CFI && MACH_CCM2200 
+	help
+	  Map driver for the battery backuped SRAM on 
+          SWARCO Traffic Systems CCM2200 board.
+
 endmenu
 
diff -Nrub '--exclude=*~' linux-orig/drivers/mtd/maps/Makefile linux-2.6.21-ccm2200/drivers/mtd/maps/Makefile
--- linux-orig/drivers/mtd/maps/Makefile	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21-ccm2200/drivers/mtd/maps/Makefile	2015-06-18 10:41:42.000000000 +0200
@@ -72,3 +72,5 @@
 obj-$(CONFIG_MTD_OMAP_NOR)	+= omap_nor.o
 obj-$(CONFIG_MTD_MTX1)		+= mtx-1_flash.o
 obj-$(CONFIG_MTD_TQM834x)	+= tqm834x.o
+obj-$(CONFIG_MTD_CCM2200_NOR)	+= ccm2200-nor.o
+obj-$(CONFIG_MTD_CCM2200_SRAM)	+= ccm2200-sram.o
diff -Nrub '--exclude=*~' linux-orig/drivers/mtd/nand/Kconfig linux-2.6.21-ccm2200/drivers/mtd/nand/Kconfig
--- linux-orig/drivers/mtd/nand/Kconfig	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21-ccm2200/drivers/mtd/nand/Kconfig	2015-06-18 10:41:42.000000000 +0200
@@ -101,6 +101,12 @@
 	help
 	  This enables the NAND flash driver on the PPChameleon EVB Board.
 
+config MTD_NAND_CCM2200
+	tristate "NAND Chip on SWARCO Traffic Systems CCM2200"
+ 	depends on MTD_NAND
+	help
+	  This enables the driver for the internal NAND on the SWARCO Traffic Systems CCM 2200
+
 config MTD_NAND_S3C2410
 	tristate "NAND Flash support for S3C2410/S3C2440 SoC"
 	depends on ARCH_S3C2410 && MTD_NAND
diff -Nrub '--exclude=*~' linux-orig/drivers/mtd/nand/Makefile linux-2.6.21-ccm2200/drivers/mtd/nand/Makefile
--- linux-orig/drivers/mtd/nand/Makefile	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21-ccm2200/drivers/mtd/nand/Makefile	2015-06-18 10:41:42.000000000 +0200
@@ -24,6 +24,7 @@
 obj-$(CONFIG_MTD_NAND_CS553X)		+= cs553x_nand.o
 obj-$(CONFIG_MTD_NAND_NDFC)		+= ndfc.o
 obj-$(CONFIG_MTD_NAND_AT91)		+= at91_nand.o
+obj-$(CONFIG_MTD_NAND_CCM2200)		+= nand_ccm2200.o
 obj-$(CONFIG_MTD_NAND_BASLER_EXCITE)	+= excite_nandflash.o
 
 nand-objs := nand_base.o nand_bbt.o
diff -Nrub '--exclude=*~' linux-orig/drivers/mtd/nand/nand_ccm2200.c linux-2.6.21-ccm2200/drivers/mtd/nand/nand_ccm2200.c
--- linux-orig/drivers/mtd/nand/nand_ccm2200.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-ccm2200/drivers/mtd/nand/nand_ccm2200.c	2015-06-18 10:41:42.000000000 +0200
@@ -0,0 +1,261 @@
+/***********************************************************************
+ *
+ * linux/drivers/mtd/nand/nand_ccm2200.c
+ *
+ * Copyright (C) 2006 by Weiss-Electronic GmbH.
+ * Copyright (C) 2010 by SWARCO Traffic Systems GmbH.
+ * All rights reserved.
+ *
+ * @author:     Guido Classen <guido.classen@swarco.de>
+ * @descr:      NAND flash driver for CCM2200
+ * @references: [1] u-boot-1.1.0/include/ns9750_nand.h
+ *              [2] spia.c
+ *              [3] nand.c
+ *              [4] nand_a9m9750.c
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ *
+ *  @par Modification History:
+ *     2006-04-24 gc: initial version (taken from nand_a9m9750.c)
+ ***********************************************************************/
+
+#include <linux/init.h>		/* __init */
+#include <linux/module.h>	/* module_init */
+#include <linux/mtd/mtd.h>	/* add_mtd_device */
+#include <linux/mtd/nand.h>	/* NAND_CMD_*  */
+#include <linux/mtd/partitions.h> /* parse_mtd_partitions */
+
+#include <asm/io.h>		/* ioremap */
+#include <asm/sizes.h>		/* SZ_ */
+#include <asm/delay.h>		/* udelay */
+#include <asm/arch/hardware.h>  /* AT91_SYS */
+#include <asm/arch/at91-util.h>
+#include <asm/arch/board-ccm2200.h>
+
+#include <asm/arch/at91_pio.h>
+#include <asm/arch/at91rm9200_mc.h>
+
+static struct mtd_info* ccm2200_mtd = NULL;
+
+
+#define NAND_FLASH_DAT	(0x0000) /* Data Read/Write */
+#define NAND_FLASH_ADR	(0x2000) /* Adr Write */
+#define NAND_FLASH_CMD	(0x4000) /* Cmd Write */
+
+#define NAND_IO_ADDR(x)  ((x)->IO_ADDR_W+NAND_FLASH_DAT)
+#define NAND_CMD_ADDR(x) ((x)->IO_ADDR_W+NAND_FLASH_CMD)
+#define NAND_ADR_ADDR(x) ((x)->IO_ADDR_W+NAND_FLASH_ADR)
+
+#ifdef CONFIG_MTD_PARTITIONS
+/*
+ * Define static partitions for flash device
+ */
+static struct mtd_partition partition_info[] = {
+        /*
+         * {
+         *         .name   = "nand-u-boot",
+         *         .size   = 256*1024,
+         *         .offset = 0,
+         *         .mask_flags     = MTD_WRITEABLE,  /\* force read-only *\/
+         * },
+         */
+/* 
+ *         {
+ *                 .name   = "nand-kernel",
+ * //                .size   = (3*1024*1024)-(256*1024),
+ * //                .offset = 256*1024,
+ *                 .size   = (3*1024*1024),
+ *                 .offset = 0,
+ *         },
+ *         {
+ *                 .name   = "nand-rootfs",
+ *                 .offset = 3*1024*1024,
+ *                 .size   = MTDPART_SIZ_FULL,
+ *         },
+ */
+        {
+                .name   = "nand-all", /* for Memory Validation Test */
+                .offset = 0,
+                .size   = MTDPART_SIZ_FULL,
+        }
+};
+
+static const char* probes[] = { "cmdlinepart", NULL };
+# define NUM_PARTITIONS (sizeof(partition_info) / sizeof(partition_info[0]))
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static void ccm2200_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,
+				   unsigned int ctrl)
+
+{
+	register struct nand_chip *this = mtd->priv;
+
+	if (cmd != NAND_CMD_NONE) {
+
+		writeb(cmd, (unsigned long)this->IO_ADDR_W
+		       | (ctrl & NAND_CLE ? NAND_FLASH_CMD : 0)
+		       | (ctrl & NAND_ALE ? NAND_FLASH_ADR : 0) );
+	}
+}
+
+
+/*
+ *	read device NAND Ready/_Busy signal using gpio pin
+ */
+static int ccm2200_nand_device_ready(struct mtd_info *minfo)
+{
+	//return ((AT91_SYS->PIOA_PDSR & AT91C_PIO_PA19) != 0) ? 1 : 0;
+	return ((at91_sys_read(AT91_PIOA + PIO_PDSR) & (1<<19)) != 0) ? 1 : 0;
+}
+
+static int __init ccm2200_nand_init( void )
+{
+	struct nand_chip* this;
+	int mtd_parts_nb = 0;
+	struct mtd_partition *mtd_parts = 0;
+	const char *part_type = 0;
+	void __iomem *nand_virt_base;
+        
+        /*
+         * Setup static memory controller chip select for NAND Flash
+         *
+         */
+        static const struct at91_smc_cs_info __initdata nand_cs_config = {
+                .chip_select          = CCM2200_NAND_FLASH_CS,
+                .wait_states          = 5,
+                .data_float_time      = 2,
+                .byte_access_type     = AT91_BAT_8_BIT,
+                .data_bus_width       = AT91_DATA_BUS_WIDTH_8,
+                .data_read_protocol   = AT91_DRP_STANDARD,
+                .address_to_cs_setup  = AT91_ACSS_STANDARD,
+                .rw_setup             = 1,
+                .rw_hold              = 1
+        };
+        printk ( KERN_INFO "CCM2200 NAND driver\n" );
+        /* let u-boot do static memory controller initialization */
+        if ( at91_config_smc_cs( &nand_cs_config ) != 0 )
+	{
+	    printk( KERN_ERR 
+                    "Unable to configure NAND flash chip select signal\n" );
+            return -EIO;
+	}
+
+	/* Allocate memory for MTD device structure and private data */
+	ccm2200_mtd = kmalloc( sizeof(struct mtd_info)+sizeof(struct nand_chip),
+			       GFP_KERNEL );
+	if ( !ccm2200_mtd ) {
+		printk( "Unable to allocate CCM2200 MTD device structure.\n" );
+		return -ENOMEM;
+	}
+
+	nand_virt_base = ioremap_nocache( CCM2200_NAND_FLASH_PHYS, 
+                                          CCM2200_NAND_FLASH_SIZE );
+	if ( !nand_virt_base ) {
+		printk( "ioremap CCM2200 NAND flash failed\n" );
+		kfree( ccm2200_mtd );
+		return -EIO;
+	}
+	printk("NAND Flash memory mapped to virtual %p\n", nand_virt_base);
+
+	/* Get pointer to private data */
+	this = (struct nand_chip *) ( &ccm2200_mtd[ 1 ] );
+
+	/* Initialize structures */
+	memset((char *) ccm2200_mtd, 0, sizeof( struct mtd_info ) );
+	memset((char *) this, 0, sizeof( struct nand_chip ) );
+
+	ccm2200_mtd->name = "CCM2200";
+
+	/* Link the private data with the MTD structure */
+	ccm2200_mtd->priv = this;
+
+	/* Set address of NAND IO lines */
+	this->IO_ADDR_R = nand_virt_base;
+	this->IO_ADDR_W = nand_virt_base;
+	/* Set address of hardware control function */
+	this->cmd_ctrl = ccm2200_nand_cmd_ctrl;
+	this->dev_ready = ccm2200_nand_device_ready;
+
+	/* 15 us command delay time */
+	this->chip_delay = 15;
+	this->ecc.mode = NAND_ECC_SOFT;
+
+        /* 2006-09-27 gc: do we need this? */
+	//this->options = NAND_SAMSUNG_LP_OPTIONS; 
+
+
+	/* Scan to find existence of the device */
+	if ( nand_scan( ccm2200_mtd, 1 ) ) {
+                printk ( "CCM2200 NAND chip not found!\n" );
+		kfree( ccm2200_mtd );
+		return -ENXIO;
+	}
+
+	/* Allocate memory for internal data buffer */
+/* 	this->data_buf = kmalloc(sizeof(u_char)*(ccm2200_mtd->oobblock+ */
+/* 						 ccm2200_mtd->oobsize), */
+/* 				 GFP_KERNEL); */
+/* 	if ( !this->data_buf ) { */
+/* 		printk ( "Unable to allocate NAND data buffer for CCM2200.\n" ); */
+/* 		iounmap(  (void*) nand_virt_base ); */
+/* 		kfree( ccm2200_mtd ); */
+/* 		return -ENOMEM; */
+/* 	} */
+
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+	mtd_parts_nb = parse_mtd_partitions( ccm2200_mtd, probes, &mtd_parts, 0);
+	if (mtd_parts_nb > 0)
+		part_type = "command line";
+	else
+		mtd_parts_nb = 0;
+#endif
+	if (mtd_parts_nb == 0)
+	{
+		mtd_parts = partition_info;
+		mtd_parts_nb = NUM_PARTITIONS;
+		part_type = "static";
+	}
+
+	/* Register the partitions */
+	printk(KERN_NOTICE "Using %s partition definition\n", part_type);
+	add_mtd_partitions( ccm2200_mtd, mtd_parts, mtd_parts_nb);
+
+	/* Return happy */
+	return 0;
+}
+device_initcall( ccm2200_nand_init );
+
+static void __exit ccm2200_cleanup( void )
+{
+	//struct nand_chip *this = (struct nand_chip *) &ccm2200_mtd[1];
+
+	iounmap( (void*) ((struct nand_chip*)ccm2200_mtd[1].priv)->IO_ADDR_R );
+
+	/* Unregister the device */
+	del_mtd_device( ccm2200_mtd );
+
+	/* Free internal data buffer */
+/* 	kfree( this->data_buf ); */
+
+	/* Free the MTD device structure */
+	kfree( ccm2200_mtd );
+}
+module_exit( ccm2200_cleanup );
+
+MODULE_LICENSE( "GPL" );
+MODULE_AUTHOR( "Guido Classen <guido.classen@swarco.de" );
+MODULE_DESCRIPTION( "Board-specific glue layer for NAND flash on CCM2200 board");
diff -Nrub '--exclude=*~' linux-orig/drivers/serial/8250.c linux-2.6.21-ccm2200/drivers/serial/8250.c
--- linux-orig/drivers/serial/8250.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21-ccm2200/drivers/serial/8250.c	2015-06-18 10:41:42.000000000 +0200
@@ -45,6 +45,9 @@
 #include <asm/irq.h>
 
 #include "8250.h"
+#ifdef CONFIG_MACH_CCM2200
+#include <asm/arch/board-ccm2200.h>
+#endif
 
 /*
  * Configuration:
@@ -1205,6 +1208,9 @@
 
 	do {
 		ch = serial_inp(up, UART_RX);
+#ifdef CONFIG_MACH_CCM2200
+                ccm2200_board_serial_trigger_led(&up->port.ccm2200_serial->rxLed);
+#endif
 		flag = TTY_NORMAL;
 		up->port.icount.rx++;
 
@@ -1274,6 +1280,10 @@
 	int count;
 
 	if (up->port.x_char) {
+#ifdef CONFIG_MACH_CCM2200
+                ccm2200_board_serial_trigger_led(&up->port.ccm2200_serial->txLed);
+		ccm2200_board_serial_rs485_tx(&up->port);
+#endif
 		serial_outp(up, UART_TX, up->port.x_char);
 		up->port.icount.tx++;
 		up->port.x_char = 0;
@@ -1289,6 +1299,10 @@
 	}
 
 	count = up->tx_loadsz;
+#ifdef CONFIG_MACH_CCM2200
+        ccm2200_board_serial_trigger_led(&up->port.ccm2200_serial->txLed);
+	ccm2200_board_serial_rs485_tx(&up->port);
+#endif
 	do {
 		serial_out(up, UART_TX, xmit->buf[xmit->tail]);
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
@@ -1836,7 +1850,8 @@
 	spin_lock_irqsave(&up->port.lock, flags);
 	if (up->port.flags & UPF_FOURPORT) {
 		/* reset interrupts on the AST Fourport board */
-		inb((up->port.iobase & 0xfe0) | 0x1f);
+          /* 2006-04-26 gc: fix arm compilation: inb_p */
+		inb_p((up->port.iobase & 0xfe0) | 0x1f);
 		up->port.mctrl |= TIOCM_OUT1;
 	} else
 		up->port.mctrl &= ~TIOCM_OUT2;
@@ -2273,6 +2288,9 @@
 };
 
 static struct uart_8250_port serial8250_ports[UART_NR];
+#ifdef CONFIG_MACH_CCM2200
+static struct ccm2200_board_serial ccm2200_board_serial[UART_NR];
+#endif
 
 static void __init serial8250_isa_init_ports(void)
 {
@@ -2300,6 +2318,10 @@
 		up->mcr_force = ALPHA_KLUDGE_MCR;
 
 		up->port.ops = &serial8250_pops;
+
+#ifdef CONFIG_MACH_CCM2200
+                ccm2200_board_serial_init(&up->port, &ccm2200_board_serial[i]);
+#endif
 	}
 
 	for (i = 0, up = serial8250_ports;
diff -Nrub '--exclude=*~' linux-orig/drivers/serial/atmel_serial.c linux-2.6.21-ccm2200/drivers/serial/atmel_serial.c
--- linux-orig/drivers/serial/atmel_serial.c	2016-03-22 14:41:04.000000000 +0100
+++ linux-2.6.21-ccm2200/drivers/serial/atmel_serial.c	2015-06-18 10:41:42.000000000 +0200
@@ -55,12 +55,27 @@
 #warning "Revisit"
 #define PDC_RX_TIMEOUT		(3 * 10)		/* 3 bytes */
 
+
+#ifdef CONFIG_MACH_CCM2200
+
+/* 
+ *     @todo 2007-06-05 gc: 
+ *     PDC DMA transmit / receives not supported by CCM2200 board specific 
+ *     serial handling
+ */
+#undef SUPPORT_PDC
+#endif
+
 #if defined(CONFIG_SERIAL_ATMEL_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
 #define SUPPORT_SYSRQ
 #endif
 
 #include <linux/serial_core.h>
 
+#ifdef CONFIG_MACH_CCM2200
+#include <asm/arch/board-ccm2200.h>
+#endif
+
 #ifdef CONFIG_SERIAL_ATMEL_TTYAT
 
 /* Use device name ttyAT, major 204 and minor 154-169.  This is necessary if we
@@ -139,6 +154,9 @@
 };
 
 static struct atmel_uart_port atmel_ports[ATMEL_MAX_UART];
+#ifdef CONFIG_MACH_CCM2200
+static struct ccm2200_board_serial ccm2200_board_serial[ATMEL_MAX_UART];
+#endif
 
 #define PDC_RX_BUF(port)	&(port)->pdc_rx[(port)->pdc_rx_idx]
 #define PDC_RX_SWITCH(port)	(port)->pdc_rx_idx = !(port)->pdc_rx_idx
@@ -279,6 +297,13 @@
 static void atmel_enable_ms(struct uart_port *port)
 {
 	UART_PUT_IER(port, ATMEL_US_RIIC | ATMEL_US_DSRIC | ATMEL_US_DCDIC | ATMEL_US_CTSIC);
+        /* 2007-02-07 gc: bugfix, also set port->read_status_mask to enable
+         * additional sources in interrupt!!!!
+	 * is this needed anymore?
+         */
+        port->read_status_mask |= ATMEL_US_RIIC | ATMEL_US_DSRIC 
+                | ATMEL_US_DCDIC | ATMEL_US_CTSIC;
+
 }
 
 /*
@@ -432,6 +457,10 @@
 	while (status & ATMEL_US_RXRDY) {
 		ch = UART_GET_CHAR(port);
 
+#ifdef CONFIG_MACH_CCM2200
+                ccm2200_board_serial_trigger_led(&port->ccm2200_serial->rxLed);
+#endif
+
 		port->icount.rx++;
 
 		flg = TTY_NORMAL;
@@ -485,7 +514,12 @@
 	struct circ_buf *xmit = &port->info->xmit;
 
 	if (port->x_char) {
+#ifdef CONFIG_MACH_CCM2200
+                ccm2200_board_serial_trigger_led(&port->ccm2200_serial->txLed);
+		ccm2200_board_serial_rs485_tx(port);
+#endif
 		UART_PUT_CHAR(port, port->x_char);
+
 		port->icount.tx++;
 		port->x_char = 0;
 		return;
@@ -495,6 +529,13 @@
 		return;
 	}
 
+#ifdef CONFIG_MACH_CCM2200
+        if (UART_GET_CSR(port) & ATMEL_US_TXRDY) {
+                 ccm2200_board_serial_trigger_led(&port->ccm2200_serial->txLed);
+		 ccm2200_board_serial_rs485_tx(port);
+
+        }
+#endif
 	while (UART_GET_CSR(port) & ATMEL_US_TXRDY) {
 		UART_PUT_CHAR(port, xmit->buf[xmit->tail]);
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
@@ -989,6 +1030,9 @@
 	if (atmel_port->use_dma_tx)
 		port->fifosize = PDC_BUFFER_SIZE;
 #endif
+#ifdef CONFIG_MACH_CCM2200
+	ccm2200_board_serial_init(port, &ccm2200_board_serial[pdev->id]);
+#endif
 }
 
 /*
@@ -1004,7 +1048,9 @@
 		atmel_pops.set_mctrl = fns->set_mctrl;
 	atmel_open_hook		= fns->open;
 	atmel_close_hook	= fns->close;
+	if (fns->pm)
 	atmel_pops.pm		= fns->pm;
+	if (fns->set_wake)
 	atmel_pops.set_wake	= fns->set_wake;
 }
 
@@ -1014,6 +1060,13 @@
 {
 	while (!(UART_GET_CSR(port) & ATMEL_US_TXRDY))
 		barrier();
+#ifdef CONFIG_MACH_CCM2200
+	if (port->ccm2200_serial) {
+                  ccm2200_board_serial_trigger_led(&port->ccm2200_serial->txLed);
+		  ccm2200_board_serial_rs485_tx(port);
+	}
+#endif
+
 	UART_PUT_CHAR(port, ch);
 }
 
@@ -1218,6 +1271,10 @@
 	struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
 	int ret = 0;
 
+#ifdef CONFIG_MACH_CCM2200
+	ccm2200_board_serial_remove(port);
+#endif
+
 	clk_disable(atmel_port->clk);
 	clk_put(atmel_port->clk);
 
diff -Nrub '--exclude=*~' linux-orig/drivers/serial/serial_core.c linux-2.6.21-ccm2200/drivers/serial/serial_core.c
--- linux-orig/drivers/serial/serial_core.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21-ccm2200/drivers/serial/serial_core.c	2015-06-18 10:41:42.000000000 +0200
@@ -1128,6 +1128,14 @@
 
 	default: {
 		struct uart_port *port = state->port;
+#ifdef CONFIG_MACH_CCM2200
+		
+		int ccm2200_board_serial_ioctl(struct uart_port *port, 
+					       unsigned int cmd, 
+					       unsigned long arg);
+		ret = ccm2200_board_serial_ioctl(port, cmd, arg);
+		if (ret == -ENOIOCTLCMD) 
+#endif
 		if (port->ops->ioctl)
 			ret = port->ops->ioctl(port, cmd, arg);
 		break;
@@ -2115,6 +2123,10 @@
 		 * We probably don't need a spinlock around this, but
 		 */
 		spin_lock_irqsave(&port->lock, flags);
+                /* 2006-05-04 gc: bugfix, don't deactivate modem control lines
+                 *                from serial console!
+                 */
+		if (!uart_console(port))
 		port->ops->set_mctrl(port, 0);
 		spin_unlock_irqrestore(&port->lock, flags);
 
diff -Nrub '--exclude=*~' linux-orig/include/asm-arm/arch-at91/at91-util.h linux-2.6.21-ccm2200/include/asm-arm/arch-at91/at91-util.h
--- linux-orig/include/asm-arm/arch-at91/at91-util.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-ccm2200/include/asm-arm/arch-at91/at91-util.h	2015-06-18 10:41:42.000000000 +0200
@@ -0,0 +1,237 @@
+/*
+ * linux/include/asm-arm/arch-at91rm9200/at91-util.h
+ *
+ * Copyright (C) 2006 by Weiss-Electronic GmbH.
+ * Copyright (C) 2010 by SWARCO Traffic Systems GmbH.
+ * All rights reserved.
+ *
+ * @author:     Guido Classen <guido.classen@swarco.de>
+ * @descr:      Generic utitliy functions for AT91RM9200 CPU 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  @par Modification History:
+ *     2006-05-05 gc: initial version
+ */
+
+#ifndef __ASM_ARCH_AT91_UTIL_H
+#define __ASM_ARCH_AT91_UTIL_H
+
+#include <asm/hardware.h>
+
+/****************************************************************************
+ * define some constants for easer usage of at91_set_gpio_direction() 
+ ****************************************************************************/
+
+#define GPIO_OUTPUT     0
+#define GPIO_INPUT      1
+#define GPIO_NO_PULLUP  0
+#define GPIO_USE_PULLUP 1
+#define GPIO_INIT_0     0
+#define GPIO_INIT_1     1
+
+
+/****************************************************************************
+ * generic AT91RM9200 specific functions
+ ****************************************************************************/
+struct at91_smc_cs_info
+{
+        int chip_select;              /* number of chip select pin */
+        int wait_states;              /* wait states 0...128 (0 = no wait
+                                       * states) */
+        int data_float_time;          /* 0...15 wait states after memory read
+                                           cycle */
+        enum byte_access_type {       /* only valid for
+                                       * data_bus_width=16bit */
+                AT91_BAT_8_BIT  = 0,  /* dummy value for 8 bit device
+                                       * (ignored) */
+                AT91_BAT_TWO_8_BIT = 0,     /* chip select is connected to
+                                             * two/four 8-bit devices */
+                AT91_BAT_16_BIT = 1   /* chip select is connected toone 16 bit
+                                       * device */
+        } byte_access_type;
+
+        enum data_bus_width {
+                AT91_DATA_BUS_WIDTH_8 = 2,  /* 8 bit data bus */
+                AT91_DATA_BUS_WIDTH_16 = 1, /* 16 bit data bus */
+        } data_bus_width;
+        enum data_read_protocol {
+                AT91_DRP_STANDARD = 0,      /* standard data read protocol */
+                AT91_DRP_EARLY    = 1,      /* early data read protocol */
+        } data_read_protocol;
+
+        enum address_to_cs_setup {
+                AT91_ACSS_STANDARD   = 0,   /* standard: address asserted at
+                                             * the beginning of the access and
+                                             * deasserted at the end */
+                AT91_ACSS_1_CYCLE    = 1,   /* one cycle less at the beginning
+                                             * and end */
+                AT91_ACSS_2_CYCLES   = 2,   /* two cycles less at the
+                                             * beginning and end */
+                AT91_ACSS_3_CYCLES   = 3    /* three cycles less at the
+                                             * beginning and end */
+        } address_to_cs_setup;
+        int rw_setup;                       /* 0...7 number of read/write
+                                                 setup cycles */
+        int rw_hold;                        /* 0...7 number of read/write hold
+                                                 cycles */
+};
+
+
+/* 
+ * Configure the static memory controller chip select register using
+ * values in struct at91_smc_cs_info
+ */
+int at91_config_smc_cs( const struct at91_smc_cs_info *info );
+
+
+/****************************************************************************
+ * multiple bits capable access to PIO controller ports
+ ****************************************************************************/
+typedef unsigned AT91_REG;
+
+/* relative address PIOs */
+typedef struct _AT91S_PIO {
+	AT91_REG	 PIO_PER;	// PIO Enable Register
+	AT91_REG	 PIO_PDR;	// PIO Disable Register
+	AT91_REG	 PIO_PSR;	// PIO Status Register
+	AT91_REG	 Reserved6[1];	//
+	AT91_REG	 PIO_OER;	// Output Enable Register
+	AT91_REG	 PIO_ODR;	// Output Disable Registerr
+	AT91_REG	 PIO_OSR;	// Output Status Register
+	AT91_REG	 Reserved7[1];	//
+	AT91_REG	 PIO_IFER;	// Input Filter Enable Register
+	AT91_REG	 PIO_IFDR;	// Input Filter Disable Register
+	AT91_REG	 PIO_IFSR;	// Input Filter Status Register
+	AT91_REG	 Reserved8[1];	//
+	AT91_REG	 PIO_SODR;	// Set Output Data Register
+	AT91_REG	 PIO_CODR;	// Clear Output Data Register
+	AT91_REG	 PIO_ODSR;	// Output Data Status Register
+	AT91_REG	 PIO_PDSR;	// Pin Data Status Register
+	AT91_REG	 PIO_IER;	// Interrupt Enable Register
+	AT91_REG	 PIO_IDR;	// Interrupt Disable Register
+	AT91_REG	 PIO_IMR;	// Interrupt Mask Register
+	AT91_REG	 PIO_ISR;	// Interrupt Status Register
+	AT91_REG	 PIO_MDER;	// Multi-driver Enable Register
+	AT91_REG	 PIO_MDDR;	// Multi-driver Disable Register
+	AT91_REG	 PIO_MDSR;	// Multi-driver Status Register
+	AT91_REG	 Reserved9[1];	//
+	AT91_REG	 PIO_PPUDR;	// Pull-up Disable Register
+	AT91_REG	 PIO_PPUER;	// Pull-up Enable Register
+	AT91_REG	 PIO_PPUSR;	// Pad Pull-up Status Register
+	AT91_REG	 Reserved10[1];	//
+	AT91_REG	 PIO_ASR;	// Select A Register
+	AT91_REG	 PIO_BSR;	// Select B Register
+	AT91_REG	 PIO_ABSR;	// AB Select Status Register
+} AT91S_PIO, *AT91PS_PIO;
+
+#define AT91C_BASE_PIOA		0xfffff400 /* base PIO controller A */
+#define AT91C_BASE_PIOB		0xfffff600 /* base PIO controller B */
+#define AT91C_BASE_PIOC		0xfffff800 /* base PIO controller C */
+#define AT91C_BASE_PIOD		0xfffffa00 /* base PIO controller D */
+
+
+#define AT91C_VA_BASE_PIOA	AT91_IO_P2V(AT91C_BASE_PIOA)
+#define AT91C_VA_BASE_PIOB	AT91_IO_P2V(AT91C_BASE_PIOB)
+#define AT91C_VA_BASE_PIOC	AT91_IO_P2V(AT91C_BASE_PIOC)
+#define AT91C_VA_BASE_PIOD	AT91_IO_P2V(AT91C_BASE_PIOD)
+
+/* #define AT91_PIOA               ((AT91S_PIO*) AT91C_VA_BASE_PIOA) */
+/* #define AT91_PIOB               ((AT91S_PIO*) AT91C_VA_BASE_PIOB) */
+/* #define AT91_PIOC               ((AT91S_PIO*) AT91C_VA_BASE_PIOC) */
+/* #define AT91_PIOD               ((AT91S_PIO*) AT91C_VA_BASE_PIOD) */
+//#define AT91_PIO_BASE(pio)      ((AT91S_PIO __iomem *) ((unsigned char __iomem *) AT91_VA_BASE_SYS + (pio)))
+
+
+#define AT91_PIO_BASE(pio) ((AT91S_PIO __iomem *)(AT91_IO_P2V(((unsigned long) (pio)) + AT91_BASE_SYS)))
+/* describe 1...32 pins of a PIO port */
+struct at91_pio_pins {
+        AT91S_PIO* pio;
+        u32 signal_bit;
+};
+
+static inline
+void at91_pio_clear_all_pins(const struct at91_pio_pins *pins)
+{
+        pins->pio->PIO_CODR = pins->signal_bit; /* set pin to 0 */
+}
+
+static inline
+void at91_pio_set_all_pins(const struct at91_pio_pins *pins)
+{
+        pins->pio->PIO_SODR = pins->signal_bit; /* set pin to 1 */
+}
+
+static inline
+void at91_pio_assign_pins(const struct at91_pio_pins *pins, u32 value)
+{
+        pins->pio->PIO_SODR = value & pins->signal_bit; /* set pin to 1 */
+}
+
+static inline
+int at91_pio_get_pins(const struct at91_pio_pins *pins)
+{
+        return pins->pio->PIO_PDSR & pins->signal_bit;
+}
+
+static inline
+void at91_pio_config_output_pins(const struct at91_pio_pins *pins)
+{
+        register AT91S_PIO *pio = pins->pio;
+        
+        register u32 signal_bit = pins->signal_bit;
+        
+        pio->PIO_IDR = signal_bit; /* disable interrupt */
+        pio->PIO_PPUDR = signal_bit; /* disable pull up */
+        /* pio->PIO_SODR = signal_bit; /\* set pin to 1  *\/ */
+        pio->PIO_OER  = signal_bit; /* enable output */
+        pio->PIO_PER = signal_bit; /* assign gpio to pin! */
+}
+
+static inline
+void at91_pio_config_input_pins(const struct at91_pio_pins *pins)
+{
+        register AT91S_PIO *pio = pins->pio;
+
+        register u32 signal_bit = pins->signal_bit;
+        
+        pio->PIO_IDR = signal_bit; /* disable interrupt */
+        pio->PIO_PPUDR = signal_bit; /* disable pull up */
+        pio->PIO_ODR  = signal_bit; /* disable output */
+        pio->PIO_PER = signal_bit; /* assign gpio to pin! */
+}
+
+/* enable open drain output (multi drive) */
+static inline
+void at91_pio_enable_open_drain_pins(const struct at91_pio_pins *pins)
+{
+        pins->pio->PIO_MDER = pins->signal_bit;
+}
+
+/* disable open drain output (multi drive) */
+static inline
+void at91_pio_disable_open_drain_pins(const struct at91_pio_pins *pins)
+{
+        pins->pio->PIO_MDDR = pins->signal_bit;
+}
+
+#endif /* __ASM_ARCH_BOARD_CCM2200_H */
+
+/*
+ *Local Variables:
+ * mode: c
+ * c-file-style: "linux"
+ * End:
+ */
diff -Nrub '--exclude=*~' linux-orig/include/asm-arm/arch-at91/board-ccm2200.h linux-2.6.21-ccm2200/include/asm-arm/arch-at91/board-ccm2200.h
--- linux-orig/include/asm-arm/arch-at91/board-ccm2200.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-ccm2200/include/asm-arm/arch-at91/board-ccm2200.h	2015-06-18 10:41:42.000000000 +0200
@@ -0,0 +1,155 @@
+/*
+ * linux/include/asm-arm/arch-at91rm9200/board-ccm2200.h
+ *
+ * Copyright (C) 2006 by Weiss-Electronic GmbH.
+ * Copyright (C) 2010 by SWARCO Traffic Systems GmbH.
+ * All rights reserved.
+ *
+ * @author:     Guido Classen <guido.classen@swarco.de>
+ * @descr:      bord specific defines for the CCM2200 board
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  @par Modification History:
+ *     2006-05-02 gc: initial version
+ */
+
+#ifndef __ASM_ARCH_BOARD_CCM2200_H
+#define __ASM_ARCH_BOARD_CCM2200_H
+
+
+/****************************************************************************
+ * Constants for CCM2200 memory map
+ ****************************************************************************/
+
+/* 
+ * PHYS 0: internal memory, CS0: NOR-Flash, CS1: SD-RAM common defined in
+ * hardware.h for all AT91RM9200 based boards 
+ */
+
+
+/* CS2: SRAM */
+#define CCM2200_SRAM_CS                 2
+#define CCM2200_SRAM_PHYS               AT91_CHIPSELECT_2
+#define CCM2200_SRAM_SIZE               (2*1024*1024)
+
+
+/* CS3: NAND-Flash */
+#define CCM2200_NAND_FLASH_CS           3
+#define CCM2200_NAND_FLASH_PHYS         AT91_CHIPSELECT_3
+#define CCM2200_NAND_FLASH_SIZE         0x8000
+
+/* CS4: external quad UART */
+#define CCM2200_QUAD_UART_CS            4
+#define CCM2200_QUAD_UART_PHYS          AT91_CHIPSELECT_4
+#define CCM2200_QUAD_UART_SIZE          0x20
+
+/* CS5: digital output */
+#define CCM2200_DIG_OUT_CS              5
+#define CCM2200_DIG_OUT_PHYS            AT91_CHIPSELECT_5
+#define CCM2200_DIG_OUT_SIZE            0x1
+
+/* CS6: extension board */
+#define CCM2200_EXT_A_CS                6
+#define CCM2200_EXT_A_PHYS              AT91_CHIPSELECT_6
+
+/* CS7: extension board */
+#define CCM2200_EXT_B_CS                7
+#define CCM2200_EXT_B_PHYS              AT91_CHIPSELECT_7
+
+/****************************************************************************
+ * Definitions for external SC16C754 quad UART
+ ****************************************************************************/
+
+#define CCM2200_QUAD_UART_IRQ           AT91RM9200_ID_IRQ0
+#define CCM2200_QUAD_UART_CLOCK_RATE    (18432000/2)
+
+#define CCM2200_PIN_PCK1_UART_CLOCK     AT91_PIN_PA24
+#define CCM2200_PIN_UART_RESET          AT91_PIN_PB2
+#define CCM2200_PIN_UART_IRQ            AT91_PIN_PB29
+
+#define CCM2200_QUAD_UART_PORT_OFFSET   0x8
+#define CCM2200_QUAD_UART_NUM_PORTS     4
+
+
+/* initialize AT91 UART subclass driver and configure ports */
+int __init ccm2200_at91_uart_init(void);
+#define AT91RM9200_PIN_DBG_UART_TXD     AT91_PIN_PA31
+#define AT91RM9200_PIN_DBG_UART_RXD     AT91_PIN_PA30
+
+
+/****************************************************************************
+ * access to CCM2200 frontpanel LEDs and digital outputs
+ * (defined in ccm2200_gpio.c)
+ ****************************************************************************/
+void ccm2200_set_digital_output(register __u32 data, register __u32 mask);
+void ccm2200_set_frontpanel_leds(register __u32 data, register __u32 mask);
+__u32 ccm2200_get_sconf_input(void);
+__u32 ccm2200_get_digital_input(void);
+
+/****************************************************************************
+ * CCM2200 board specific serial extended functions (RS485 and LED support)
+ ****************************************************************************/
+
+#include <linux/ccm2200_serial.h>
+#include <linux/timer.h>
+
+struct ccm2200_led_handler {
+        struct ccm2200_serial_led led;
+        struct timer_list led_timer;
+};
+
+struct uart_port;
+#include <linux/serial_core.h>  /* struct uart_ops */
+
+struct ccm2200_board_serial
+{
+        /* 
+         * remember state for kernel driven RS485 modes,
+         * in normal RS232 operation we stay always in 
+         * CCM2200_BS_RECEIVE
+         */
+        enum ccm2200_board_serial_state {
+                CCM2200_BS_NOT_INITIALIZED = 0,
+                CCM2200_BS_RECEIVE,
+                CCM2200_BS_DCD_WAIT, /* DCD wait on in multi-drop modem mode */
+                CCM2200_BS_TURN_ON_DELAY,
+                CCM2200_BS_CTS_WAIT,
+                CCM2200_BS_TRANSMIT,
+                CCM2200_BS_TURN_OFF_DELAY
+        } state;
+
+        struct ccm2200_serial_config conf;
+        struct ccm2200_led_handler rxLed;
+        struct ccm2200_led_handler txLed;
+        struct uart_ops ccm2200_ops;
+        struct uart_ops *orig_ops;
+        struct timer_list turn_on_off_timer;
+};
+
+void ccm2200_board_serial_init(struct uart_port *port,
+                               struct ccm2200_board_serial *se);
+void ccm2200_board_serial_remove(struct uart_port *port);
+void ccm2200_board_serial_trigger_led(struct ccm2200_led_handler *led);
+void ccm2200_board_serial_rs485_tx(struct uart_port *port);
+
+#endif /* __ASM_ARCH_BOARD_CCM2200_H */
+
+/*
+ *Local Variables:
+ * mode: c
+ * c-file-style: "linux"
+ * End:
+ */
diff -Nrub '--exclude=*~' linux-orig/include/asm-arm/arch-at91/uncompress.h linux-2.6.21-ccm2200/include/asm-arm/arch-at91/uncompress.h
--- linux-orig/include/asm-arm/arch-at91/uncompress.h	2016-03-22 14:41:04.000000000 +0100
+++ linux-2.6.21-ccm2200/include/asm-arm/arch-at91/uncompress.h	2015-06-18 10:41:42.000000000 +0200
@@ -24,6 +24,26 @@
 #include <asm/io.h>
 #include <asm/arch/at91_dbgu.h>
 
+#ifdef CONFIG_MACH_CCM2200
+
+#define UART_BASE AT91RM9200_BASE_US2
+#define UART_SR   (UART_BASE+0x14)
+#define UART_THR   (UART_BASE+0x1c)
+
+static void putc(int c)
+{
+	while (!(__raw_readl(UART_SR) & AT91_DBGU_TXRDY))
+		barrier();
+	__raw_writel(c, UART_THR);
+}
+static inline void flush(void)
+{
+	/* wait for transmission to complete */
+	while (!(__raw_readl(UART_SR) & AT91_DBGU_TXEMPTY))
+		barrier();
+}
+
+#else
 /*
  * The following code assumes the serial port has already been
  * initialized by the bootloader.  If you didn't setup a port in
@@ -49,6 +69,8 @@
 		barrier();
 }
 
+#endif
+
 #define arch_decomp_setup()
 
 #define arch_decomp_wdog()
diff -Nrub '--exclude=*~' linux-orig/include/asm-arm/param.h linux-2.6.21-ccm2200/include/asm-arm/param.h
--- linux-orig/include/asm-arm/param.h	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21-ccm2200/include/asm-arm/param.h	2015-06-18 10:41:42.000000000 +0200
@@ -18,6 +18,18 @@
 # define HZ		100
 #endif
 
+/* 2007-06-05 gc:  */
+#ifdef CONFIG_MACH_CCM2200
+#undef HZ
+//#  define HZ		200		/* Internal kernel timer frequency */
+//#  define HZ		250		/* Internal kernel timer frequency */
+//#  define HZ		333		/* Internal kernel timer frequency */
+//#  define HZ		256
+#  define HZ		1024
+//#  define HZ		1000
+#endif
+
+
 #define EXEC_PAGESIZE	4096
 
 #ifndef NOGROUP
diff -Nrub '--exclude=*~' linux-orig/include/linux/ccm2200_gpio.h linux-2.6.21-ccm2200/include/linux/ccm2200_gpio.h
--- linux-orig/include/linux/ccm2200_gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-ccm2200/include/linux/ccm2200_gpio.h	2015-06-18 10:41:42.000000000 +0200
@@ -0,0 +1,59 @@
+/*
+ * linux/include/linux/ccm2200_gpio.h
+ *
+ * Copyright (C) 2006 by Weiss-Electronic GmbH.
+ * Copyright (C) 2010 by SWARCO Traffic Systems GmbH.
+ * All rights reserved.
+ *
+ * @author:     Guido Classen <guido.classen@swarco.de>
+ * @descr:      Userspace access to CCM2200 digital in-/output lines
+ *              and indicator LEDs
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  @par Modification History:
+ *     2006-05-04 gc: initial version (partly derived from ite_gpio.h
+ *                    written by Hai-Pao Fan <haipao@mvista.com>)
+ */
+
+#ifndef __CCM2200_GPIO_H
+#define __CCM2200_GPIO_H
+
+#include <linux/ioctl.h>
+
+struct ccm2200_gpio_ioctl_data {
+	__u32 device;
+	__u32 mask;
+	__u32 data;
+};
+
+#define CCM2200_GPIO_IOCTL_BASE	'g'
+
+#define CCM2200_GPIO_IN		_IOWR(CCM2200_GPIO_IOCTL_BASE, 0, struct ccm2200_gpio_ioctl_data)
+#define CCM2200_GPIO_OUT	_IOW (CCM2200_GPIO_IOCTL_BASE, 1, struct ccm2200_gpio_ioctl_data)
+#define CCM2200_GPIO_SET	_IOW (CCM2200_GPIO_IOCTL_BASE, 2, struct ccm2200_gpio_ioctl_data)
+#define CCM2200_GPIO_CLEAR	_IOW (CCM2200_GPIO_IOCTL_BASE, 3, struct ccm2200_gpio_ioctl_data)
+
+#define	CCM2200_GPIO_INPUT	0x01
+#define	CCM2200_GPIO_OUTPUT	0x02
+#define	CCM2200_GPIO_LED	0x03
+#define	CCM2200_GPIO_SCONF	0x04
+
+
+/* Watchdog LED ioctl */
+#define	CCM2200_WATCHDOG_IOCTL_BASE	'W'
+#define	CCM2200_WDIOC_SETLED    _IOWR(WATCHDOG_IOCTL_BASE, 100, int)
+
+#endif
diff -Nrub '--exclude=*~' linux-orig/include/linux/ccm2200_serial.h linux-2.6.21-ccm2200/include/linux/ccm2200_serial.h
--- linux-orig/include/linux/ccm2200_serial.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-ccm2200/include/linux/ccm2200_serial.h	2015-06-18 10:41:42.000000000 +0200
@@ -0,0 +1,98 @@
+/*
+ * linux/include/linux/ccm2200_serial.h
+ *
+ * Copyright (C) 2007 by Weiss-Electronic GmbH.
+ * Copyright (C) 2010 by SWARCO Traffic Systems GmbH.
+ * All rights reserved.
+ *
+ * @author:     Guido Classen <guido.classen@swarco.de>
+ * @descr:      CCM2200 board specific ioctl to configure special serial port
+ *              operating modes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  @par Modification History:
+ *     2007-02-01 gc: initial version
+ */
+
+#ifndef __CCM2200_SERIAL_H
+#define __CCM2200_SERIAL_H
+
+#include <linux/ioctl.h>
+
+struct ccm2200_serial_config {
+	enum ccm2200_serial_mode {
+                /* normal RS232 configuration, no modification to standard Linux
+		 * Kernel behavior (e.g. for all AT-Modems) 
+		 */
+		CCM2200_SERIAL_MODE_NORMAL,   
+
+                /* RTS Pin driven by UART-hardware (Atmel only, no
+		 * Weiss/CC2200+ RS-485) 
+		 */
+		CCM2200_SERIAL_MODE_RS485HW,  
+
+		/* Kernel-Software driven RTS pin (UART TX-Empty
+		 * Interrupt) (not implemented) 
+		 */
+		CCM2200_SERIAL_MODE_RS485INT, 
+
+		/* Multi-drop modem controlled by host via
+		 * modem-control lines ignoring DCD signal (e.g. Loges
+		 * 1200MD) 
+		 */
+		CCM2200_SERIAL_MODE_MODEM_MD, 
+
+		/* Multi-drop modem controlled by host via
+		 * modem-control lines waiting for DCD signal
+		 * (e.g. Loges 1200MD) 
+		 */
+		CCM2200_SERIAL_MODE_MODEM_MD_DCD, 
+
+		/* Software driven RS-485 (Weiss Piggyback/CC2200+)
+		 * with RTS pin, no evalution of any other control
+		 * signal (CTS, DCD, RI)
+		 */
+		CCM2200_SERIAL_MODE_RS485KERN,
+
+		/* Software driven RS-485 (Weiss Piggyback/CC2200+)
+		 * with RTS pin (inverted), no evalution of any other
+		 * control signal (CTS, DCD, RI).  Using this mode RTS
+		 * is inactive during transmission and active while
+		 * receiving
+		 */
+		CCM2200_SERIAL_MODE_RS485KERN_NEG,
+	} mode;
+	__u32 turn_on_delay;	    /* RS485 transmitter turn on delay  */
+	__u32 turn_off_delay;	    /* RS485 transmitter turn off delay */
+};
+
+
+struct ccm2200_serial_led {
+	__u32 mask;
+	__u32 delay;
+};
+
+
+#define CCM2200_SERIAL_IOCTL_BASE	'w'
+
+#define CCM2200_SERIAL_GET_CONF		_IOR(CCM2200_SERIAL_IOCTL_BASE, 0, struct ccm2200_serial_config)
+#define CCM2200_SERIAL_SET_CONF		_IOW(CCM2200_SERIAL_IOCTL_BASE, 1, struct ccm2200_serial_config)
+#define CCM2200_SERIAL_GET_TX_LED	_IOR(CCM2200_SERIAL_IOCTL_BASE, 2, struct ccm2200_serial_led)
+#define CCM2200_SERIAL_SET_TX_LED	_IOW(CCM2200_SERIAL_IOCTL_BASE, 3, struct ccm2200_serial_led)
+#define CCM2200_SERIAL_GET_RX_LED	_IOR(CCM2200_SERIAL_IOCTL_BASE, 4, struct ccm2200_serial_led)
+#define CCM2200_SERIAL_SET_RX_LED	_IOW(CCM2200_SERIAL_IOCTL_BASE, 5, struct ccm2200_serial_led)
+
+#endif
diff -Nrub '--exclude=*~' linux-orig/include/linux/serial_core.h linux-2.6.21-ccm2200/include/linux/serial_core.h
--- linux-orig/include/linux/serial_core.h	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21-ccm2200/include/linux/serial_core.h	2015-06-18 10:41:42.000000000 +0200
@@ -276,6 +276,10 @@
 	struct device		*dev;			/* parent device */
 	unsigned char		hub6;			/* this should be in the 8250 driver */
 	unsigned char		unused[3];
+#ifdef CONFIG_MACH_CCM2200
+	struct ccm2200_board_serial *ccm2200_serial;
+#endif
+
 };
 
 /*
@@ -336,6 +340,9 @@
 
 struct module;
 struct tty_driver;
+#ifdef CONFIG_MACH_CCM2200
+struct ccm2200_board_serial;
+#endif
 
 struct uart_driver {
 	struct module		*owner;
diff -Nrub '--exclude=*~' linux-orig/Makefile linux-2.6.21-ccm2200/Makefile
--- linux-orig/Makefile	2016-03-22 14:41:04.000000000 +0100
+++ linux-2.6.21-ccm2200/Makefile	2015-06-18 10:41:42.000000000 +0200
@@ -412,7 +412,11 @@
 include $(srctree)/arch/$(ARCH)/Makefile
 export KBUILD_DEFCONFIG
 
-config %config: scripts_basic outputmakefile FORCE
+config: scripts_basic outputmakefile FORCE
+	$(Q)mkdir -p include/linux include/config
+	$(Q)$(MAKE) $(build)=scripts/kconfig $@
+
+%config: scripts_basic outputmakefile FORCE
 	$(Q)mkdir -p include/linux include/config
 	$(Q)$(MAKE) $(build)=scripts/kconfig $@
 
@@ -1437,7 +1441,11 @@
 	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
 
 # Modules
-/ %/: prepare scripts FORCE
+/: prepare scripts FORCE
+	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1) \
+	$(build)=$(build-dir)
+
+%/: prepare scripts FORCE
 	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1) \
 	$(build)=$(build-dir)
 %.ko: prepare scripts FORCE
